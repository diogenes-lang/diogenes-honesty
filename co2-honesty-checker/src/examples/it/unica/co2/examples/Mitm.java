package it.unica.co2.examples;


import static it.unica.co2.api.contract.utils.ContractFactory.*;
import it.unica.co2.api.Session2;
import it.unica.co2.api.contract.Contract;
import it.unica.co2.api.contract.ContractDefinition;
import it.unica.co2.api.contract.Recursion;
import it.unica.co2.api.contract.Sort;
import it.unica.co2.api.process.CO2Process;
import it.unica.co2.api.process.Participant;
import it.unica.co2.honesty.HonestyChecker;
import co2api.ContractException;
import co2api.ContractExpiredException;
import co2api.Message;
import co2api.Public;
import co2api.TST;
import co2api.TimeExpiredException;

/*
 * auto-generated by co2-plugin
 * creation date: 16-11-2015 14:58:48
 */

@SuppressWarnings("unused")
public class Mitm {
	
	private static String username = "test@co2-plugin.com";
	private static String password = "test";
	
	
	/*
	 * contracts declaration
	 */
	private static ContractDefinition Cattacker = def("Cattacker");
	
	/*
	 * contracts initialization
	 */
	static {
		Cattacker.setContract(internalSum().add("plain", Sort.STRING, internalSum().add("cipher", Sort.STRING, internalSum().add("min", Sort.INT, internalSum().add("max", Sort.INT, externalSum().add("ok", Sort.UNIT, externalSum().add("fstKey", Sort.STRING, externalSum().add("sndKey", Sort.STRING))).add("no", Sort.UNIT))))));
	}
	
	public static class Attacker extends Participant {
		
		private static final long serialVersionUID = 1L;
		
		public Attacker() {
			super(username, password);
		}
		
		@Override
		public void run() {
			
			
			parallel(()->{
				Session2<TST> x = tellAndWait(Cattacker);
				processCall(attack.class, x,1,10);
			});
			
			parallel(()->{
				Session2<TST> x_1 = tellAndWait(Cattacker);
				processCall(attack.class, x_1,11,20);
			});
		}
	}
	
	public static class attack extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session2<TST> x;
		private Integer min;
		private Integer max;
		
		public attack(Session2<TST> x,Integer min,Integer max) {
			super(username, password);
			this.x=x;
			this.min=min;
			this.max=max;
		}
		
		@Override
		public void run() {
			x.send("plain", "plaintext");
			x.send("cipher", "ciphertext");
			x.send("min", min);
			x.send("max", max);
			processCall(handleResponse.class, x);
		}
	}
	
	public static class handleResponse extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session2<TST> x;
		
		public handleResponse(Session2<TST> x) {
			super(username, password);
			this.x=x;
		}
		
		@Override
		public void run() {
			logger.log("waiting on 'x' for actions [ok,no]");
			Message msg = x.waitForReceive("ok","no");
			
			switch (msg.getLabel()) {			
				
				case "ok":
					logger.log("received [ok]");

					logger.log("waiting on 'x' for actions [fstKey]");
					Message msg_1 = x.waitForReceive("fstKey");
					
					logger.log("received [fstKey]");
					String k1;
					try {
						k1 = msg_1.getStringValue();
					}
					catch (ContractException e) {
						throw new RuntimeException(e);
					}
					logger.log("waiting on 'x' for actions [sndKey]");
					Message msg_2 = x.waitForReceive("sndKey");
					
					logger.log("received [sndKey]");
					String k2;
					try {
						k2 = msg_2.getStringValue();
					}
					catch (ContractException e) {
						throw new RuntimeException(e);
					}
					break;
				
				case "no":
					logger.log("received [no]");
					break;
				
				default:
					throw new IllegalStateException("You should not be here");
			}
		}
	}
	
	public static void main(String[] args) {
		HonestyChecker.isHonest(Attacker.class);
	}
}
