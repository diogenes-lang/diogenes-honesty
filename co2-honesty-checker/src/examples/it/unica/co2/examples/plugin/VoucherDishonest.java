package it.unica.co2.examples.plugin;

import static it.unica.co2.api.contract.utils.ContractFactory.*;

import co2api.ContractException;
import co2api.Message;
import co2api.Public;
import co2api.Session;
import co2api.TST;
import co2api.TimeExpiredException;
import it.unica.co2.api.contract.ContractDefinition;
import it.unica.co2.api.contract.Sort;
import it.unica.co2.api.process.Participant;

/*
 * auto-generated by co2-plugin
 * creation date: 04-09-2015 11:16:44
 */

@SuppressWarnings("unused")
public class VoucherDishonest {
	
	private static String username = "test@co2-plugin.com";
	private static String password = "test";
	
	
	/*
	 * contracts declaration
	 */
	private static ContractDefinition CB = def("CB");
	private static ContractDefinition CV = def("CV");
	
	/*
	 * contracts initialization
	 */
	static {
		CB.setContract(externalSum().add("clickPay", Sort.unit(), externalSum().add("pay", Sort.string())).add("clickVoucher", Sort.unit(), internalSum().add("reject", Sort.unit(), externalSum().add("pay", Sort.string())).add("accept", Sort.unit(), externalSum().add("voucher", Sort.string()))));
		CV.setContract(externalSum().add("ok", Sort.unit()).add("no", Sort.unit()));
	}
	
	public static class P extends Participant {
		
		private static final long serialVersionUID = 1L;
		
		public P() {
			super(username, password);
		}
		
		@Override
		public void run() {
			Public<TST> pbl$x$CB = tell(CB.getContract());
			Session<TST> x = pbl$x$CB.waitForSession();
			
			logger.log("waiting on 'x' for actions [clickPay,clickVoucher]");
			Message msg$0 = x.waitForReceive("clickPay","clickVoucher");
			
			switch (msg$0.getLabel()) {			
				
				case "clickPay":
					logger.log("received [clickPay]");
					logger.log("waiting on 'x' for actions [pay]");
					Message msg$1 = x.waitForReceive("pay");
					
					String code$pay$msg2;
					try {
						code$pay$msg2 = msg$1.getStringValue();
					}
					catch (ContractException e) {
						throw new RuntimeException(e);
					}
					break;
				
				case "clickVoucher":
					logger.log("received [clickVoucher]");
					new Q(x).run();
					break;
				
				default:
					throw new IllegalStateException("You should not be here");
			}
		}
	}
	
	public static class Q extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session<TST> x;
		
		public Q(Session<TST> x) {
			super(username, password);
			this.x=x;
		}
		
		@Override
		public void run() {
			Public<TST> pbl$y$CV = tell(CV.getContract());
			
			try {
				Session<TST> y = pbl$y$CV.waitForSession(10000);
				new Q1(x,y).run();
			}
			catch(TimeExpiredException e) {
				
				parallel(()->{
					new abortX(x).run();
				});
				
				parallel(()->{
					Session<TST> y$0 = pbl$y$CV.waitForSession();
					new abortY(y$0).run();
				});
			}
		}
	}
	
	public static class Q1 extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session<TST> x;
		private Session<TST> y;
		
		public Q1(Session<TST> x,Session<TST> y) {
			super(username, password);
			this.x=x;
			this.y=y;
		}
		
		@Override
		public void run() {
			try {
				logger.log("waiting on 'y' for actions [ok,no]");
				Message msg$0 = y.waitForReceive(10000, "ok","no");
				
				switch (msg$0.getLabel()) {			
					
					case "ok":
						logger.log("received [ok]");
						x.sendIfAllowed("accept");
						logger.log("waiting on 'x' for actions [voucher]");
						Message msg$1 = x.waitForReceive("voucher");
						
						String v$voucher$msg2;
						try {
							v$voucher$msg2 = msg$1.getStringValue();
						}
						catch (ContractException e) {
							throw new RuntimeException(e);
						}
						break;
					
					case "no":
						logger.log("received [no]");
						x.sendIfAllowed("reject");
						logger.log("waiting on 'x' for actions [pay]");
						Message msg$2 = x.waitForReceive("pay");
						
						String code$pay$msg3;
						try {
							code$pay$msg3 = msg$2.getStringValue();
						}
						catch (ContractException e) {
							throw new RuntimeException(e);
						}
						break;
					
					default:
						throw new IllegalStateException("You should not be here");
				}
			}
			catch (TimeExpiredException e) {
				new R1(x,y).run();
			}
			
		}
	}
	
	public static class R1 extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session<TST> x;
		private Session<TST> y;
		
		public R1(Session<TST> x,Session<TST> y) {
			super(username, password);
			this.x=x;
			this.y=y;
		}
		
		@Override
		public void run() {
			new abortX(x).run();
		}
	}
	
	public static class abortX extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session<TST> x;
		
		public abortX(Session<TST> x) {
			super(username, password);
			this.x=x;
		}
		
		@Override
		public void run() {
			x.sendIfAllowed("reject");
			logger.log("waiting on 'x' for actions [pay]");
			Message msg$0 = x.waitForReceive("pay");
			
			String code$pay$msg1;
			try {
				code$pay$msg1 = msg$0.getStringValue();
			}
			catch (ContractException e) {
				throw new RuntimeException(e);
			}
		}
	}
	
	public static class abortY extends Participant {
		
		private static final long serialVersionUID = 1L;
		private Session<TST> y;
		
		public abortY(Session<TST> y) {
			super(username, password);
			this.y=y;
		}
		
		@Override
		public void run() {
			logger.log("waiting on 'y' for actions [ok,no]");
			Message msg$0 = y.waitForReceive("ok","no");
			
			switch (msg$0.getLabel()) {			
				
				case "ok":
					logger.log("received [ok]");
					break;
				
				case "no":
					logger.log("received [no]");
					break;
				
				default:
					throw new IllegalStateException("You should not be here");
			}
		}
	}
	
	public static void main(String[] args) {
		new P().run();
	}
}
