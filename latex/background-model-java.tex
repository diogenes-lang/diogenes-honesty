
\chapter{Model checking Java programs}\label{chap:model-java}

Model-checking is a technique that allows to verify if a software program satisfies certain properties in \emph{all possible states}.
\Cref{sec:model-checking} describes some basic notions of model-checking, mainly extracted from \cite{baier2008principles}, while \Cref{sec:jpf} shows Java PathFinder, a Java model-checker.

\section{Model checking}\label{sec:model-checking}
In software and hardware design of complex systems, more time and effort are spent on
verification than on construction. Techniques are sought to reduce and ease the verification efforts while increasing their coverage. Formal methods offer a large potential to obtain an early integration of verification in the design process, to provide more effective verification techniques, and to reduce the verification time.

During the last two decades, research in formal methods has led to the development of
some very promising verification techniques that facilitate the early detection of defects. These techniques are accompanied by powerful software tools that can be used to automate various verification steps.

Model checking is a verification technique that explores all possible system states in a brute-force manner.  Similar to a computer chess program that checks possible moves, a model checker, the software tool that performs the model checking, examines all possible system scenarios in a systematic manner. In this way, it can be shown that a given system model truly satisfies a certain property. It is a real challenge to examine the largest possible state spaces that can be treated with current means, i.e., processors and memories. State-of-the-art model checkers can handle state spaces of about $10^8$ to $10^9$ states with explicit state-space enumeration. Using clever algorithms and tailored data structures, larger state spaces ($10^{20}$ up to even $10^{476}$ states) can be handled for specific problems. Even the subtle
errors that remain undiscovered using emulation, testing and simulation can potentially be revealed using model checking.

Typical properties that can be checked using model checking are of a qualitative nature: Is the generated result OK?, Can the system reach a deadlock situation, e.g., when two concurrent programs are waiting for each other and thus halting the entire system?  But also timing properties can be checked: Can a deadlock occur within 1 hour after a system reset?, or, Is a response always received within 8 minutes?  Model checking requires a precise and unambiguous statement of the properties to be examined.  As with making an accurate system model, this step often leads to the discovery of several ambiguities and inconsistencies in the informal documentation.  For instance, the formalization of all system properties for a subset of the ISDN user part protocol revealed that 55\% (!) of the original, informal system requirements were inconsistent.

\subsubsection{Modeling}
The prerequisite inputs to model checking are a model of the system under
consideration and a formal characterization of the property to be checked.

Models of systems describe the behavior of systems in an accurate  and unambiguous
way. They are mostly expressed using finite-state automata, consisting of a finite set
of states and a set of transitions. States comprise information about the current values of variables, the previously executed statement (e.g., a program counter), and the like. Transitions describe how the system evolves from one state into another.

\section{Java PathFinder}\label{sec:jpf}
This section is mainly extracted from \cite{jpf-site} and aims to take an overview of what is Java PathFinder in order to understand how we use it in this work.

Java PathFinder (JPF) started as a software model checker, but nowadays there are various different execution modes and extensions, runtime configured and not hardwired, which are used to verify Java programs, to find and explain defects, collect "deep" runtime information like coverage metrics, etc.

\subsubsection{Core}
The JPF core is a Virtual Machine (VM) for Javaâ„¢ bytecode, which means it is a program which you give Java programs to execute. It is used to find defects in these programs, so you also need to give it the properties to check for as input. JPF gets back to you with a report that says if the properties hold and/or which verification artifacts have been created by JPF for further analysis (like test cases).

JPF is a VM with several twists. It is implemented in Java itself, so does not expect it to run as fast as your normal Java. It is a VM running on top of a VM. While execution semantics of Java bytecodes are clearly defined in Sun's Java Virtual Machine Specification, the semantics in JPF is little hardwired  - the VM instruction set is represented by a set of classes that can be replaced.

The default instruction set makes use of the next JPF feature: \emph{execution choices}. JPF can identify points in your program from where execution could proceed differently, then systematically explore all of them. This means JPF (theoretically) executes all paths through your program, not just one like a normal VM. Typical choices are different scheduling sequences or random values, but again JPF allows you to introduce your own type of choices like user input or statemachine events\footnote{We use this feature to explore all possible input that come from the \coco middleware, as explained in \Cref{chap:java-honesty}.}.

The number of paths can grow out of hand, and it usually will. This is what software model checking calls the state explosion problem. The first line of defense employed by JPF is state matching: each time JPF reaches a choice point, it checks if it has already seen a similar program state, in which case it can safely abandon this path, backtrack to a previous choice point that has still unexplored choices, and proceed from there. That is right, JPF can restore program states, which is like telling a debugger ``go back 100 instructions".

So what are these features used for? Normally to find defects in the program you want to verify, but what kind of defects? By now you know the answer: it depends on how you configure JPF. The core checks for defects that can be identified by the VM without you having to specify any property: deadlocks and unhandled exceptions (which also covers Java assert expressions). These are called non-functional properties, and no application should violate them. But JPF does not stop there - you can define your own properties, which is mostly done with so called \emph{listeners}, little ``plugins" that let you closely monitor all actions taken by JPF, like executing single instructions, creating objects, reaching a new program state and many more. 

One additional feature that comes in handy in case JPF finds a defect is the availability of the complete execution history that leads to the bug, down to every executed bytecode instruction if you need it. It is called program trace and it is invaluable to find out what really caused the defect. Think of a deadlock - usually there is not much you can directly deduce from a snapshot of call stacks.

Summing up, JPF automatically executes your program in all possible ways to find defects you do not even know about yet, then it explains you what caused these defects.

\subsubsection{Caveat: not a lightweight tool}
Of course that is the ideal world. In reality, this can require quite a lot of configuration and even some programming. JPF is not a ``black box" tool like a compiler, and the learning curve can be steep. What makes this worse is that JPF cannot execute Java libraries that make use of native code. Not because it does not know how to do that, but because it often does not make sense: native code like system calls to write to a file cannot easily be reverted - JPF would loose its capability to match or backtrack program states. But of course there is a remedy, and it is configurable: native peers and model classes. Native peers are classes that hold methods that are executed in lieu of real native methods. This code is executed by the real Java VM, not JPF, hence it can also speed up things. Model classes are simple replacements of standard classes, like \incodeType{java.lang.Thread} that provide alternatives for native methods which are fully observable and backtrackable.

\subsection{Choice generators}
Software model checking is all about doing the right choices, to reach the interesting system states within the resource constraints of the tool and execution environment. JPF systematically explore the state space using \emph{choice generators}.
 
Choice generators are used to generate multiple states next explored by JPF. The interface \incodeType{gov.nasa.jpf.jvm.Verify} provides useful methods to do that, \eg you can invoke \incodeKeyword{boolean}\incode{ b = }\incodeType{Verify}.\incodeMethod{getBoolean()} and JPF automatically handles its invocation creating and exploring both states, one with \incode{b==true} and the other with \incode{b==false}.

\subsection{Listeners}
Listeners are perhaps the most important extension mechanism of JPF. They provide a way to observe, interact with and extend JPF execution with your own classes. Since listeners are dynamically configured at runtime, they do not require any modification to the JPF core. Listeners are executed at the same level like JPF, so there is hardly any limit of what we can do with them.

The general principle is simple: JPF provides an Observer pattern\footnote{\url{https://en.wikipedia.org/wiki/Observer_pattern} (visited on 2015-08)} implementation that notifies registered observer instances about certain events at the search (and JVM) level. These notifications cover a broad spectrum of JPF operations, from low level events like \textit{instructionExecuted} to high level events like \textit{searchFinished}. Each notification is parameterized with the corresponding source (either the \textit{Search} or the \textit{JVM} instance), which can be then used by the notified listener to obtain more information about the event/JPF's internal state.
 
There are two basic listener interfaces, depending on corresponding event sources: \textit{SearchListeners} and \textit{VMListeners}. Since these interfaces are quite large, and listeners often need to implement both, ``adapter" classes were provided, i.e. implementors that contain all required method definitions with empty method bodies. Concrete listeners that extend these adapters therefore only have to override the notification methods they are interested in.

The adapter classes are used for the majority of listener implementations, especially since they also support two other interfaces/extension mechanisms that are often used in conjunction with Search/VMListeners: \textit{Property} (to define program properties) and \textit{PublisherExtension} (to produce output within the JPF reporting system).
 
\textit{ListenerAdapter} is the bare adapter implementation for \textit{SearchListener}, \textit{VMListener} and \textit{PublisherExtension}. This is what is mostly used to collect information during JPF execution.
 
\textit{PropertyListenerAdapter} is used in case the listener implements a program property, i.e. can terminate the search process. 

Choosing the right type for your listener is important, since JPF automatically registers listeners (and properties) based on this type. You can bypass and directly implement single listener interfaces, but then you also have to do the proper registrations.

Usually, the notification alone is not enough, and the listener needs to acquire more information from JPF. For this purpose, JPF provides either the search or the vm object as notification arguments, and the listener has to use these as \textit{facades} to query or interact with it.