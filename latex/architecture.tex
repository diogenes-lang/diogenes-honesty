\section{Architecture}

Diogenes has three main components:
an honesty checker for \coco,
an honesty checker for Java,
and an Eclipse plugin which integrates the two analyses
with an editor of \coco.
We illustrate the architecture of our tools in~\Cref{fig:architecture}.

The \coco honesty checker implements the  
verification technique introduced in~\cite{BMSZ15jlamp}.
This technique is built upon an alternative semantics of \coco 
which abstracts both values (sent, received, and in conditional expressions) 
and the actual \emph{context} wherein a process is executed.
This abstraction is a \emph{sound} over-approximation of honesty:
namely, if the abstraction of a process is honest,
then also the concrete one is honest.
Further, in the fragment of \coco without conditional statements
the analysis is also \emph{complete},
\ie if a concrete process is honest, then also its abstraction is honest.
For processes without delimitation/parallel under process definitions,
the associate abstraction is finite-state, 
hence we can verify their honesty by model checking a (finite) state space.
Our implementation 
first translates a \coco process into a Maude term~\cite{Maude01}, 
and then uses the Maude LTL model checker~\cite{Eker02maude}
to decide honesty of its abstract semantics.

%\paragraph{Diogenes.}
The Java honesty checker is developed on top of \emph{Java PathFinder}
(JPF, \cite{lerda2001addressing,visser2003model}).
The JPF core is a Virtual Machine for Java bytecode
that can be configured to act as a model-checker.
%
\niconote{ho cambiato qualcosa qua sotto}
A \emph{listener} allows us to catch specific method invocations, 
which represent I/O actions
directed to the middleware~\cite{CO2middleware},
and to simulate \emph{all} the possible responses that 
the application can receive from it.
%
JPF creates a \emph{choice generator} and explore all of these,
backtracking when the state exploration is done.
%
Therefore, the program is executed and backtracked multiple times,
and we are able to obtain a \coco model that represents its behaviour.
Then, the verification relies to the model checking technique of~\cite{BMSZ15jlamp}.
%
\bartnote{+ commento sulla tecnica di analisi: ad esempio, sotto quali ipotesi e' corretta?}
However, if the \code{@SkipMethod} presented in the previous section
is abused, some discrepancies between the program and the model
can occur, \eg annotating a method that never returns.
\niconote{non so se intendeva qualcosa del genere}


The Eclipse plugin \bartnote{dire prima cosa fa, e poi dare qualche insight}
% On the contrary, the Eclipse plugin has no dependencies, and
% it integrates the possibility to directly call 
% the Maude model-checker, reporting its output into the Eclipse console.
%
The plugin relies on
Xtext~\cite{xtext-site}, a framework for developing programming languages, 
and Xsemantics~\cite{xsemantics-site}, a domain-specific language for writing type systems
for Xtext-based languages.
%
We use Xtext to define the grammar of \coco.
\bartnote{giusto? si usa per altre cose? c'e' da dire altre cose interessanti sul plugin? mi sembra che questa parte andrebbe espanda un poco}
% We implement an Xtext grammar focusing on~\cite{BMSZ15jlamp},
% and we extend it in order to allow a complete mapping between \coco and Java.


\begin{figure}[t]
    \includegraphics[width=\textwidth]{img/diogenes-arch.png}
    \caption{Data flow schema}
    \label{fig:architecture}
\end{figure}