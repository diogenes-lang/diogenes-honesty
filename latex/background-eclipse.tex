
\chapter{Eclipse plugin development}\label{chap:eclipse-pde}

A part of this master thesis is the development of an Eclipse plugin that will help the \coco users to write their own processes taking advantage of basic feature such as syntax highlighting, content assist, validation, types check an so on. In order to do so, we discovered \emph{Xtext} \cite{xtext-site}, a framework for development of domain specific languages (DSL) developed in the Eclipse Project as part of the Eclipse Modeling Framework Project, and \emph{Xsemantics} \cite{xsemantics-site}, a tool for writing type systems, reduction rules, interpreters (and in general relation rules) for languages implemented in Xtext.

This chapter provides the basic notions required to understand the implementative part of the thesis: in \Cref{sec:eclipse-overview} we provide an overview of the Eclipse platform and its plugin mechanism (mainly extracted from the Eclipse official documentation \cite{eclipse-official}), then we focus on Xtext and Xsemantics showing their the main aspects, respectively in \Cref{sec:xtext} and \Cref{sec:xsematics}. 

\section{Eclipse overview}\label{sec:eclipse-overview}
The Eclipse platform is structured around the concept of plug-ins. Plug-ins are structured bundles of code and/or data that contribute functionality to the system. Functionality can be contributed in the form of code libraries (Java classes with public API), platform extensions, or even documentation. Plug-ins can define extension points, well-defined places where other plug-ins can add functionality.

Each subsystem in the platform is itself structured as a set of plug-ins that implement some key function. Some plug-ins add visible features to the platform using the extension model. Others supply class libraries that can be used to implement system extensions.

The Eclipse SDK includes the basic platform plus two major tools that are useful for plug-in development.  The Java development tools (JDT) implement a full featured Java development environment.  The Plug-in Developer Environment (PDE) adds specialized tools that streamline the development of plug-ins and extensions.

These tools not only serve a useful purpose, but also provide a great example of how new tools can be added to the platform by building plug-ins that extend the system. Figure \ref{img:eclipse-sdk} show the basic architectural schema.

\begin{figure}
\centering
\includegraphics[scale=0.6]{img/eclipse-sdk-arch}
\caption[The Eclipse SDK architecture]{The Eclipse SDK architecture.}
\label{img:eclipse-sdk}
\end{figure}

\subsection{Runtime core}
The platform runtime engine is started when a user starts an application developed with Eclipse. The runtime implements the basic plug-in model and infrastructure used by the platform. It keeps track of all installed plug-ins and the functionality that they provide.

A plug-in is a structured component that contributes code (or documentation or both) to the system and describes it in a structured way. Plug-ins can define \emph{extension points}, well-defined function points that can be extended by other plug-ins. When a plug-in contributes an implementation for an extension point, we say that it adds an \emph{extension} to the platform. These extensions and extension points are declared in the plug-ins's manifest (\emph{plugin.xml}) file.

Using a common extension model provides a structured way for plug-ins to describe the ways they can be extended, and for client plug-ins to describe the extensions they supply. Defining an extension point is much like defining any other API. The only difference is that the extension point is declared using XML instead of a code signature. Likewise, a client plug-in uses XML to describe its specific extension to the system.

A general goal of the runtime is that the end user should not pay a memory or performance penalty for plug-ins that are installed, but not used. The declarative nature of the platform extension model allows the runtime engine to determine what extension points and extensions are supplied by a plug-in without ever running it. Thus, many plug-ins can be installed, but none will be activated until a function provided by a plug-in has been requested according to the user's activity. This is an important feature in providing a scalable, robust platform. 

\subsection{Plugin mechanism}
The mechanics for supporting plug-ins are implemented using the OSGi framework \cite{osgi-site}. What is OSGi? The best definition is given by the official site:

\begin{displayquote}
\emph{OSGi technology is a set of specifications that defines a dynamic component system for Java. These specifications reduce software complexity by providing a modular architecture for large-scale distributed systems as well as small, embedded applications.} 
\end{displayquote}

Eclipse Equinox \cite{equinox-site} is an implementation of the OSGi core framework specification, a set of bundles that implement various optional OSGi services and other infrastructure for running OSGi-based systems. The Equinox OSGi core framework implementation is used as the reference implementation and as such it implements all the required features of the latest OSGi core framework specification.

Luckily we do not need to delve further in this direction. Exploiting the modularity nature of Eclipse, our attention focused on Xtext and its extensions points. \Cref{sec:xtext} describe its main features and \Cref{sec:co2-plugin} present how we create the \coco plugin.

\section{Xtext: framework for DSL development}\label{sec:xtext}
Xtext is a framework for development of programming languages and \textit{Domain Specific Languages} (DSL) \cite{xtext-site}. The implementation of a DSL take into account not only the language itself but also all the tools you must provide to the end-users (who effectively will use your language), i.e. an editor with syntax highlighting, parsing error and semantic validation.

Xtext provides us with a set of domain-specific languages\footnote{Xbase is a partial programming language implemented in Xtext and is meant to be embedded and extended within other programming languages and DSL written in Xtext.} and modern APIs to describe the different aspects of our programming language. They include such things as the parser, the type-safe abstract syntax tree (AST), the serializer and code formatter, the scoping framework and the linking, compiler checks and static analysis aka validation and a code generator or interpreter. It is also possible to add custom implemetation to the default scoping system and implement custom validation rules that depends on the semantic of our \coco language (i.e. we do not permit to write a contract sum with a repeated action).

\subsection{Xtend}
Xtext strongly encourages you to use Xtend, a statically-typed programming language which translates to comprehensible Java source code. It improves the Java language, \ie introducing lambda expressions, extension methods, operator overloading, multiple dispatch, and so on. Since it compiles to Java code (not Bytecode), Xtend has zero interoperability issues with Java and it is only much more concise, readable and expressive than Java \cite{xtend-site}. We use it to implement all the customization needed by our language.

\subsection{Grammar definition}
Xtext provides a DSL designed for the description of textual languages. The main idea is to describe the concrete syntax and how it is mapped to an in-memory representation. This model will be produced by the parser when it consumes an input file. This model is not a simple \textit{Abstract Syntax Tree} (AST) but a graph of objects with cross-references that can be explored for adding custom validation rules or scoping behaviour.

After you write the grammar, Xtext generate the parser for your language using ANTLR (Another Tool for Language Recognition) which implements a LL(*) parser \cite{antlr-site}. Furthermore, it creates all the scaffolding classes you can use to extend the default features.

\subsection{Code generation}
Xtext provides the notion of \textit{generator} to translate/compile our language to any target language.
From the exploration of the AST, it's possible to implement multiple generators to obtain an executable program. This feature is exploited to compile the \coco language to Java and Maude\cite{Maude01}: the former provides a real implementation of a contract-oriented application, while the former can be exploited to model-check the honesty of the \coco specification, as explained in \Cref{sec:co2-model-check}. This aspects are shown in \Cref{chap:co2-to-java} and \Cref{chap:use-cases}.

\section{Xsemantics}\label{sec:xsematics}
A \emph{type-system} is a collection of rules that assigns a property (called \emph{type}) to various constructs a computer program consists of, such as \emph{variables}, \emph{expressions} or \emph{functions}. The main purpose of a type system is to reduce possibilities for bugs in computer programs checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of static and dynamic checking.

We provide a static type-system exploiting Xsemantics\cite{xsemantics-site}, a DSL (implemented in Xtext itself) for writing type systems, reduction rules, interpreters (and in general relation rules) for languages implemented in Xtext.

In Xsemantics, The type-system rules are a set of \emph{judgment rules} which have a conclusion and a set of premises; these rules can act on any Java object, though, typically, they will act on the AST derived by our language (implemented with Xtext).