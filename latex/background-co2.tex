
\section{Background}\label{sec:background}


\subsection{Session types and compliance}
A contract describes the intended behaviour of \emph{one} of the two
participants involved in a session.  We use binary session
types~\cite{Honda98esop} to define contracts.  Session types are terms
of a process algebra featuring internal/external choice, and
recursion.

We assume a set of \emph{participants} (ranged over by
${\pmv A}, {\pmv B}, \ldots$), a set of \emph{branch labels} (ranged
over by $\atom{a}, \atom{b}, \ldots$), and a set of \emph{sorts}
ranged over by $\sortT, \sortTi, \ldots$ (e.g.\ \sort{int},
\sort{bool}, \sort{unit}).  Each sort $\sort{T}$ is populated by a set
of values, ranged over by $\valV, \valVi, \ldots$; as usual, we write
$\valV: \sortT$ to indicate that $\valV$ has sort~$\sortT$.

\begin{definition}[Contracts] \label{def:contracts:syntax}
Contracts are \emph{binary session types}, i.e.\ terms defined by the grammar:
\begin{align*}
%\text{Unilateral contracts} &&
    \contrP,\contrQ \;\; & ::= \;\;
    % \textstyle
    \SumInt[i \in \mathcal{I}]{\atomOut[i]{a} \sortT[i]}{\contrP[i]} \ \bnfmid \ 
    \SumExt[i \in \mathcal{I}]{\atomIn[i]{a} \sortT[i]}{\contrP[i]} \ \bnfmid \
    % \ready{\atomIn{a}\val{v}}.c \ \bnfmid \
    \rec{\contrX}{\contrP}
    \bnfmid \ \contrX
\end{align*}
where % we assume that
\begin{inlinelist} 
\item the index set $\mathcal{I}$ is finite,
\item \label{item:def:contracts:syntax:pairwise-distinct}
the labels $\atom[i]{a}$ in the prefixes of each summation are pairwise distinct, and 
\item recursion variables $\contrX$ are prefix-guarded.
\end{inlinelist}
\end{definition}

An internal sum $\SumInt[i]{\atomOut[i]{a}\sortT[i]}{\contrP[i]}$
allows a participant to choose one of the labels $\atom[i]{a}$, to
pass a value of sort $\sortT[i]$, and then to behave according to the
branch $\contrP[i]$.  Dually, an external sum
$\SumExt[i]{\atomIn[i]{a}\sortT[i]}{\contrP[i]}$ allows to wait for
the other participant to choose one of the labels $\atom[i]{a}$, and
then to receive a value of sort $\sortT[i]$ and behave according to
the branch $\contrP[i]$.
%
Empty internal/external sums are identified, and they are denoted with
$\cnil$, which represents a \emph{success state} wherein the
interaction has terminated.

%We use the (commutative and associative) binary operators to isolate a
%branch in a sum: \eg,\
%$\contrP = (\sumI{\atomOut{a}\sortT}{\contrPi}) \sumInt \contrPii$
%means that $\contrP$ has the form
%$\SumInt[i \in \mathcal{I}]{\atomOut[i]{a}\sortT[i]}{\contrP[i]}$ and
%there exists some $i \in \mathcal{I}$ such that
%$\sumI{\atomOut{a}\sortT}{\contrPi} =
%\sumI{\atomOut[i]{a}\sortT[i]}{\contrP[i]}$.
%Hereafter, we will omit the $\sort{unit}$ sort and the trailing
%occurrences of $\cnil$, and we will only consider contracts without
%free occurrences of recursion variables~$\contrX$.

To model the behaviour of two participants {\pmv A} and {\pmv B}
involved in a session, we compose their contracts together into
$\bic{\contrP}{\contrQ}$.  Their interaction is ruled by an
operational semantics \tizinote{citare} \Cref{citare}, where the two
participants alternate in firing actions: in partcular {\pmv A} can
fire either if she has an internal choice, or if she is committed to a
branch of an external choice.
%
To do that, the syntax of~\Cref{def:contracts:syntax} has been
extended with the term $\ready{\atomIn{a}\val{v}} \contrSeq
\contrP$,
which models a participant ready to input a value $\valV$ in a branch
with label $\atom{a}$, and then to continue as $\contrP$.  In other
words, $\ready{\atomIn{a}\val{v}}$ acts as a one-position buffer
shared between the two participants.

%
%
Two composed contracts may enjoy the property of
\emph{compliance}. The intuition is that if a contract $\contrP$ is
compliant with a contract $\contrQ$, then in all the configurations of
a computation of $\bic{\contrP}{\contrQ}$, whenever a participant
wants to choose a branch in an internal sum, the other participant
always offers the opportunity to do it.  Compliance guarantees
that % \emph{progress}:
whenever a computation of %$\bic{\contrP}{\contrQ}$ 
becomes stuck, then
both participants have reached the success state $\cnil$.


\subsection{The \coco calculus and honesty}\label{sec:co2}

We model agents and systems in the process calculus 
\coco\cite{BZ10lics,BTZ12coordination,BSTZ13forte},
which we instantiate with the contracts introduced in \Cref{sec:contract-session-types}.

Let $\vars$ and $\snames$ be disjoint sets
of \emph{variables} (ranged over by $x,y,\ldots$) and 
\emph{names} (ranged over by $s,t,\ldots$).
%
We assume a language of \emph{expressions}
(ranged over by $\expE, \expEi, \ldots$),
containing variables, values, and operators 
(\eg the usual arithmetic/logic ones).
The actual choice of operators is almost immaterial for the
subsequent technical development; here we just postulate
a function $\sem{\cdot}$ which maps (closed) expressions to values.
We assume that the sort of an expression is uniquely determined 
by the sorts of its variables.
We use $u,v,\ldots$ to range over $\vars \cup \snames$,
we use $\vec{u},\vec{v},\ldots$ to range over 
sequences of variables/names, and
$\vec{e}$ to range over sequences of expressions.
To make symbols lookup easier, we have summarised the syntactic categories 
and some notation in Table~\ref{def:notation}.
% Some of the symbols defined therein will only be used in later sections.

% \begin{table}[t]
% 	\footnotesize
% 	\hrulefill
% 	% \vspace{-10pt}
% 	\[
% 	\begin{array}{ll}
	
% 	\begin{array}{ll}
% 	\pmv{A}, \pmv{B}, \ldots & \text{Participant names}
% 	\\
% 	\atom{a}, \atom{b}, \ldots & \text{Branch labels}
% 	\\
% 	\sortT, \sortTi, \ldots & \text{Sorts}
% 	\\
% 	\valV, \valVi, \ldots & \text{Values}
% 	\\
% 	\contrP, \contrQ, \ldots & \text{Contracts}
% 	\\
% 	\gamma, \gammai, \ldots & \text{Contract configurations} 
% 	\\
% 	%   \contrP \compliant \contrQ & \text{Compliance}
% 	%   \\
% 	%   \cfrown{\pmv A}{\gamma} & \text{Culpability}
% 	%   \\
% 	\gamma \cmove{} \gammai & \text{Transition of contracts}
% 	\end{array}
	
% 	& \hspace{18pt}
	
% 	\begin{array}{ll}
% 	u, v,\ldots \mbox{\hspace{50pt}} & \text{Union of:} 
% 	\\
% 	s,t, \ldots \in \snames & \text{Session names} 
% 	\\
% 	x, y, \ldots \in \vars & \text{Variables} 
% 	\\
% 	\expE, \expEi, \ldots & \text{Expressions} 
% 	\\
% 	\procP,\procQ,\ldots & \text{Processes} 
% 	\\
% 	\sysS, \sysSi,\ldots & \text{Systems}
% 	\\
% 	%   \vabscontrP, \vabssysS, \ldots & \text{Value-abstract contracts/systems}
% 	%   \\
% 	%   \cabscontrP, \abssysS, \ldots & \text{Context-abstract contracts/systems}
% 	%   \\
% 	\sysS \pmove{} \sysSi & \text{Transition of systems}
% 	\end{array}
	
% 	\end{array}
% 	\]
% 	\hrulefill
% 	\vspace{-5pt}
% 	\caption{Summary of notation.} \label{def:notation}
% \end{table}


\begin{definition}\label{def:co2:syntax}
	The syntax of \coco is defined as follows:
	\[
	\small
	\begin{array}{r@{\hskip 0.1cm}lclcccccccccccc}   
	& \sysS \, (\text{Systems}) & ::= & 
	\emptysys 
	~\bnfmid ~ \sys {\pmv A} \procP 
	\; \bnfmid \; \sys s \gamma 
	\; \bnfmid \; (u)\sysS
	\; \bnfmid \; \sysS \mid \sysS
	\; \bnfmid \; \setenum{\freeze u \contrP}_{\pmv A}
	\\[.8pc]
	
	& \procP \, (\text{Processes})& ::= &  \textstyle 
	\cocoSum[i]{\pref[i] \cocoSeq \procP[\!i]}
	\; \bnfmid \; \ifte{\expE}{\procP}{\procP}
	\; \bnfmid \; \procX(\vec u,\vec e)
	\; \bnfmid \; (u)\procP
	\; \bnfmid \; \procP \cocoPar \procP
	\\[.8pc]
	
	& \pref \, (\text{Prefixes})& ::= & \tau
	\; \bnfmid \; \tell {} {\freeze u \contrP}
	\; \bnfmid \; \fact u {\atomOut{a} e}
	\; \bnfmid \; \fact u {\atomIn{a} x : \sortT}
	\; \bnfmid \; \ask {u} {\!\phi}
	\end{array}
	\]
	If $\vec u = u_0,\hdots,u_n$,
	we will use $(\vec u) \sysS$ and $(\vec u) \procP$ 
	as shorthands for $(u_0)\cdots(u_n) \sysS$ and $(u_0)\cdots(u_n) \procP$,
	respectively. %
	We also assume the following syntactic constraints on processes and systems:
	\begin{enumerate}
		
		\item each occurrence of named processes is prefix-guarded;
		
		\item in $(\vec u)(\sys {\pmv A} \procP \mid \sys{\pmv B} \procQ \mid \cdots)$,
		it must be $\pmv A \neq \pmv B$;
		
		\item in $(\vec u)(\sys s \gamma \mid \sys t \gammai \mid \cdots)$,
		it must be $s \neq t$.
		
	\end{enumerate}
\end{definition}


\begin{figure}[t]
	\hrulefill
	\footnotesize
	\begin{center}
		commutative monoidal laws for $\mid$ on processes and systems
	\end{center}
	\vspace{-10pt}
	\[
	\begin{array}{c}
	\sys {\pmv A} {(v) \procP} \equiv \sys{(v) \, {\pmv A}} \procP 
	\hspace{20pt}
	\sysFmt{Z} \mid (u) \sysFmt{Z'} \equiv (u)(\sysFmt{Z} \mid \sysFmt{Z'}) 
	\;\;\text{if}\ u \not\in \fv{\sysFmt{Z}} \cup \fn{\sysFmt{Z}}
	\\[8pt]
	(u)(v) \sysFmt{Z} \equiv (v)(u) \sysFmt{Z}
	\hspace{20pt}
	(u) \sysFmt{Z} \equiv \sysFmt{Z}
	\;\;\text{if}\ u \not\in \fv{\sysFmt{Z}} \cup \fn{\sysFmt{Z}}
	\hspace{20pt} 
	\setenum{\freeze s \contrP}_{\pmv A} \equiv \pnil 
	\end{array}
	\]
	\hrulefill
	\vspace{-5pt}
	\caption[Structural equivalence for \coco]{Structural equivalence for \coco 
		($\sysFmt{Z},\sysFmt{Z'}$ range over systems or processes).} \label{fig:co2:equiv}
	\vspace{-10pt}
\end{figure}


\emph{Systems} $\sysS, \sysSi,\ldots$ are the parallel composition of 
\emph{participants} $\sys {\pmv A} \procP$,
\emph{sessions} $\sys s \gamma$,
\emph{delimited systems} $(u)\sysS$, 
and \emph{latent contracts} $\setenum{\freeze{u\!\!}{\contrP}}_{\pmv A}$.
A latent contract $\setenum{\freeze{x\!\!}{\contrP}}_{\pmv A}$ 
represents a contract $\contrP$ (advertised by {\pmv A}) which
has not been stipulated yet; upon stipulation, the variable $x$ will be
instantiated to a fresh session name. 
% Latent contracts of the form 
% $\setenum{{\freeze s c}_{\pmv A}}$, where $s$ is a session \emph{name} are discarded
% by the axiom $\setenum{{\freeze s c}_{\pmv A}} \equiv \pnil$ in~\Cref{fig:co2:equiv}.

\emph{Processes} $\procP, \procQ, \ldots$ are
prefix-guarded (finite) sums of processes,
conditionals $\ifte{\expE}{\procP}{\procQ}$
(where $\expE$ is a boolean valued expression),
named processes $\procX(\vec u,\vec e)$ %
(used \eg\ to specify recursive behaviours),
delimited processes $(u) \procP$,
and parallel compositions $\procP \cocoPar \procP$.

\emph{Prefixes} $\pref$ include silent action $\tau$, 
contract advertisement $\tell{}{\freeze u \contrP}$, 
output action $\fact{u}{\atomOut{a}\expE}$,
input action $\fact{u}{\atomIn{a}x:\sortT}$,
and contract query $\ask{u}{\phi}$
(where $\phi$ is an LTL formula on $\gamma$).
%
In each prefix $\pref \neq \tau$, 
the index $u$ refers to the target session involved in
the execution of $\pref$.

\smallskip
The only binder for names is the
delimitation $(u)$, both in systems and processes.
Instead, variables have two binders:
delimitations $(x)$ (both in systems and processes),
and input actions.
Namely, in a process $\fact u {\atomIn{a}x}:\sortT.\, \procP$, 
the variable $x$ in the prefix binds the occurrences of $x$ within $\procP$.
Note that ``value-kinded'' variables in input actions 
will be replaced by values,
while ``name-kinded'' variables used in delimitations 
will be replaced by session names.
Accordingly, we avoid confusion between these two kinds of variables.
For instance, we forbid
$\fact{u}{\atomIn{a}x}.\, \fact{x}{\atomOut{b}{\valV}}$
and
$(x) \, \fact{u}{\atomOut{a}{x}}$.
%
% We assume that the variables used in input actions are disjoint from 
% those used in delimitations.

Free \emph{session} names/variables in a prefix are defined as follows:
$\fnv{\tau} = \emptyset$, and
\(
\fnv{\tell{}{\freeze u \contrP}} = 
\setenum{u} = 
\fnv{\fact u {\atomOut a}\expE} =
\fnv{\fact u {\atomIn a}x:\sortT}
\).
Free variables/names of systems/processes are defined accordingly, 
and they are denoted by $\fv{}$ and $\fn{}$.
A system or a process is \emph{closed} when it has no free variables.

We write $\pref[1] \cocoSeq \procP[1] \cocoPlus \pref[2] \cocoSeq
\procP[2]$ for $\cocoSum[{i \in \setenum{1,2}}] {\pref[i]} \cocoSeq
\procP[i]$, and $\pnil$ for $\cocoSum[{\emptyset}]\procP$.
%
We stipulate that each process identifier $\procX$ 
has a unique defining equation
$\procX(x_1, \ldots, x_j) \mmdef \procP$ such that $\fv{\procP} \subseteq
\setenum{x_1,\ldots,x_j} \subseteq \vars$.
We will sometimes omit %
the arguments of $\procX(\vec u, \vec e)$ when they are clear from the context.
As usual, we omit trailing occurrences of~$\pnil$ in processes.

We call  \emph{obligations} those actions a participant $\pmv A$ at a
session $s$ in $\sysS$ has to fire.  
%
A \coco process is \emph{honest} if, in all possible interactions, it
always fulfils its contractual obligations.  

We now address the problem of automatically verifying honesty.
However, this is a desirable goal, 
because it alerts system designers before they
deploy services which could violate contracts at run-time 
(so possibly incurring in sanctions).
%
Verifying honesty in \coco is undecidable in
general~\cite{BTZ12coordination}, because one must consider \emph{all}
possible execution contexts, which are infinite.  Even with usual
syntactic restrictions required to make processes finite-state (\eg\
no delimitation/parallel under process definitions) value-passing
makes the semantics of \coco infinite-state.

Even thought, adopting the aforementioned restrictions and with an abstraction
to approximate values, a checker for honesty has been  implemented
in Maude \cite{Maude01} and described in details in \cite{verifiable}.


\subsection{Contract oriented middleware}
The following section briefly describe a \textit{contract-oriented
  middleware} \cite{CO2middleware} that aims to monitor the
interaction between mutually distrusting services and simplify the
development of distributed applications.  A service can
\textit{advertise} its contract without worrying about the search of a
\textit{compliant} peer to interact with. The middleware carry about
the creation of a session and monitors the involved services to detect
contract violations.

In order to interact with the middleware, a developer can choose
between the RESTFUL API, whose drawback is warring of the order of API
calls, and language specific API, that partially guide it to the
correct usage. At the time of writing, there is a Java API we used in
our implementation (see \Cref{chap:co2-to-java} and
\Cref{chap:java-honesty}).

\subsection{Java API}\label{sec:co2-middleware-api}

%\begin{listing}[t]
%	\inputJavaLineos{code/HelloWorld.txt}
%	\caption{Hello world.}
%	\label{lst:hello-world}
%\end{listing}

This section shows the Java API usage \textit{by example}. 

\Cref{lst:hello-world} shows a simple ``hello world'' example. %
At lines~\lineno{1-2} the process establishes 
a connection with the middleware. %
% In our first example we focus on the basic client APIs that allow to: build a new contract,
% wait for a compliant one, handle a session.
The contract (constructed at line~\lineno{4}) advertise that the
process wants to send a $\atom{greet}$ing message, and waits to
receive the name of the greeted planet.

At line~\lineno{6}, we construct a \incodeType{Private} object, in a
state where it has not been advertised to the middleware, yet. %
As soon as it is advertised by invoking the \incodeMethod{tell} method
at line~\lineno{7}, its state is changed into \incodeType{Public}.  At
line~\lineno{9}, it waits for a session to be established; so that a
\incodeType{Session} object is created, through which the process can
interact with the participant at the other endpoint.  At
line~\lineno{10}, it says \incode{hello}, by sending a message with
label $\atom{greet}$. %
%
At line~\lineno{13}, it waits to receive a \incodeType{Message}. %
If the other participant respects its contract,
\incodeMethod{getStringValue} at line~\lineno{14} 
gets the string associated to the $\atom{planet}$ action,
and the session terminates successfully. %
Otherwise, the \incodeMethod{waitForReceive} is unblocked,
and a \incodeType{ContractException} is caught at line~\lineno{12}.

You can download the Java API, the related documentation and some
examples at ????%\citeurl{CO2middleware} (visited on 2015-08).

\subsubsection{Contract advertisement}
The API allows us to advertise a contract only as plain Java
\incodeType{String} in two formats: XML and \textit{timed
  session-types} \cite{Bartoletti15forte}. The former is too verbose
and does not strictly comply our session-types definition (see
\Cref{def:contracts:syntax}); the latter is a superset of our
specification, so we prefer to use it on communicating with the
middleware.

In \Cref{chap:co2-to-java} we show an extended version of these API,
providing a Java representation for contracts.

