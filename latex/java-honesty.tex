
\section{The Java honesty checker}\label{sec:java-honesty}



\subsubsection{From \coco to java }
We implemented a \coco Eclipse plugin which allows to automatically
translate \coco processes into both a Java and a Maude process. 

The \coco Eclipse plugin is implemented with Xtext, a framework for
development of programming languages and \textit{Domain Specific
  Languages} (DSL) (\Cref{sec:xtext}).
Since the generated parser is LL(*), each DSL rule corresponds to a
Java class (instantiated when building the Abstract Syntax Tree AST) and
each declaration inside a rule is mapped to a class field.

The code generation happens navigating the AST and translating each
\coco construct to the corresponding code of the target language.
For the java process translation, we use  the Contract Oriented
Middleware'classes, albeit slightly enhanced.

The Maude representation of \coco is complete, so it is always possible to
obtain a translation and verify the honesty of the process using
\cite{verifiable}, as explained in \Cref{sec:maude:checker}. On the
other hand, as focused in \Cref{sec:untranslatable-code}, not all
processes can be translated to Java.

\subsubsection{Honesty Checker in Java}
We also implemented a class \incodeType{HonestyChecker} to verify the
honesty of Java applications. The idea is the reverse of the one in
the previous section: using \textit{Java PathFinder} (JPF) we analyze
the Java bytecode and we build up the \coco process. Then, we
translate the \coco process into a Maude process and we check its honesty.

\tizinote{dire che il check tiene conto dell'invocazione di librerie e terze parti per capire se un'azione verra' fatta davvero}

\subsubsection{Parallel processes}\label{sec:java-parallel}
The \coco parallel process maps directly to a Java
\incodeType{Thread}, which is executed asynchronously with the
callee. We use the method
\incodeMethod{parallel(\incodeType{Runnable})} in order to handle its
invocation and the start of the new thread. The method is
\emph{synchonized}, so there are not overlaps due for example to
multiple threads that try to start a parallel process. In this way,
when handling the call with JPF, we are sure to make the correct
association between the caller and the callee thread.

% The execution is now more complicated due to the scheduling of the
% spawn threads. Fortunately JPF allows to retrieve the thread
% identifier when handling the method calls, so we extend our data
% structure using a map of $\langle thread\, ID,
% \coco{}Stack\rangle$.
% When a new thread starts, it is linked to the caller and each of them
% construct its \coco process independently from the other one.

% \subsubsection{Construction flaws}
% Unfortunately, we do not care about the actions types. This originates
% from the impossibility to specify the contract actions types to the
% middleware and it is not related to other limitations.



