
\section{The Java honesty checker}\label{sec:java-honesty}



\subsubsection{From \coco to java }
We implemented a \coco Eclipse plugin which allows to automatically
translate \coco processes into both a Java and a Maude process. 

The \coco Eclipse plugin is implemented with Xtext, a framework for
development of programming languages and \textit{Domain Specific
  Languages} (DSL) (\Cref{sec:xtext}).
Since the generated parser is LL(*), each DSL rule corresponds to a
Java class (instantiated when building the Abstract Syntax Tree AST) and
each declaration inside a rule is mapped to a class field.

The code generation happens navigating the AST and translating each
\coco construct to the corresponding code of the target language.

The Maude representation of \coco is complete, so it is always possible to
obtain a translation and verify the honesty of the process using
\cite{verifiable}.

For the java process translation, we use the Contract Oriented
Middleware's classes, albeit slightly enhanced. 
We model a \coco agent $\sys{\pmv{A}}{\procP}$ as a java class 
(\incodeType{Participant}) that provides some utility methods (\eg to advertise
a contract, to wait the establishment of a session, or to spawn a \coco
parallel process) and it relieves the programmer of carrying about the
middleware details. It extends the class \incodeType{CO2Process} which
implements the \incodeType{Runnable} interface. 
%
Both Participant and CO2Process are abstract classes, so the programmer must
implement the \emph{run} method that will contain the behaviour of the process.

Not all \coco processes can be translated to java, so we focused on some
specific \coco \emph{patterns}.

\nicolanote{ho abbozzato una tabella. Mancano diversi pattern e potrebbe non starci in una pagina.}

\begin{figure}[t]
\centering
\def\arraystretch{1.5}
\setlength{\tabcolsep}{5pt}
\begin{tabular}[t]{|p{3cm}|p{8cm}|}
    \hline
    pattern &
    java code \\
    \hline\hline

%    $\tell {} {\freeze x \contrP} \cocoSeq \procP$ &
%\begin{tabminted}[breaklines,mathescape]{java}
%Contract c = ...;
%Public p = tell(c);
%// $\procP$
%\end{tabminted}
%    \\\hline
%    
%    $\tell {} {\freeze x \contrP} \cocoSeq \ask{x}{} \cocoSeq \procP$ & 
%\begin{tabminted}[breaklines,mathescape]{java}
%Contract c = ...;
%Public p = tell(c);
%Session session = waitForSession(p);
%// $\procP$
%\end{tabminted}   
%    \\\hline
    
    $\tell {} {\freeze x \contrP} \cocoSeq 
    \ask{x}{} \cocoSeq \procP[1] \cocoPlus
    \tau \cocoSeq \procP[2]$ &
\begin{tabminted}[breaklines,mathescape]{java}
Contract c = ...;
Public p = tell(c);
try {
    int timeout = ...;
    Session session = waitForSession(p,timeout);
    // $\procP[1]$
} catch(TimeExpiredException e) {
    // $\procP[2]$
}
\end{tabminted}   
    \\\hline
    
    $\fact{x}{} \atomIn{a_1} \cocoSeq \procP[1] \cocoPlus 
    \dots \cocoPlus 
    \fact{x}{} \atomIn{a_n} \cocoSeq \procP[n] \cocoPlus
    \tau \cocoSeq \procP$ &
\begin{tabminted}[breaklines,mathescape]{java}
Session x = ...;
int timeout = ...;

try {
    Message msg = x.waitForReceive(timeout, "a_1", ..., "a_n");
    
    switch(msg.getLabel()) {
    case "a_1": // $\procP[1]$
        break;
    ...
    case "a_n": // $\procP[n]$
        break;
    }
} catch(TimeExpiredException e) {
   // $\procP$
}
\end{tabminted}
    \\\hline
\end{tabular}

\end{figure}

\subsubsection{Honesty Checker in Java}
We also implemented a class \incodeType{HonestyChecker} to verify the
honesty of Java applications. The idea is the reverse of the one in
the previous section: using \textit{Java PathFinder} (JPF) we analyze
the Java bytecode and we build up the \coco process. Then, we
translate the \coco process into a Maude process and we check its honesty.

\tizinote{dire che il check tiene conto dell'invocazione di librerie e terze parti per capire se un'azione verra' fatta davvero}

\subsubsection{Parallel processes}\label{sec:java-parallel}
The \coco parallel process maps directly to a Java
\incodeType{Thread}, which is executed asynchronously with the
callee. We use the method
\incodeMethod{parallel(\incodeType{Runnable})} in order to handle its
invocation and the start of the new thread. The method is
\emph{synchonized}, so there are not overlaps due for example to
multiple threads that try to start a parallel process. In this way,
when handling the call with JPF, we are sure to make the correct
association between the caller and the callee thread.

% The execution is now more complicated due to the scheduling of the
% spawn threads. Fortunately JPF allows to retrieve the thread
% identifier when handling the method calls, so we extend our data
% structure using a map of $\langle thread\, ID,
% \coco{}Stack\rangle$.
% When a new thread starts, it is linked to the caller and each of them
% construct its \coco process independently from the other one.

% \subsubsection{Construction flaws}
% Unfortunately, we do not care about the actions types. This originates
% from the impossibility to specify the contract actions types to the
% middleware and it is not related to other limitations.



