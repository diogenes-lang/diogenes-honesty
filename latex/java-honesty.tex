
\section{The Java honesty checker}\label{sec:java-honesty}



\subsubsection{From \coco to java }
We implemented a \coco Eclipse plugin which allows to automatically
translate \coco processes into both a Java and a Maude process. 

The \coco Eclipse plugin is implemented with Xtext, a framework for
development of programming languages and \textit{Domain Specific
  Languages} (DSL) (\Cref{sec:xtext}).
Since the generated parser is LL(*), each DSL rule corresponds to a
Java class (instantiated when building the Abstract Syntax Tree AST) and
each declaration inside a rule is mapped to a class field.

The code generation happens navigating the AST and translating each
\coco construct to the corresponding code of the target language.

The Maude representation of \coco is complete, so it is always possible to
obtain a translation and verify the honesty of the process using~\cite{BCPZ15jlamp}.

For the java process translation, we use the Contract Oriented
Middleware's classes, albeit slightly enhanced. 
%
The translation is not complete, so we define a the subset \cocosub as follows:

\begin{definition}\label{def:co2sub}
	The syntax of \cocosub is defined as follows:
	\[
	\small
	\begin{array}{r@{\hskip 0.1cm}lclcccccccccccc}   
	& \sysS \, (\text{Systems}) & ::= & 
	\emptysys 
	~\bnfmid ~ \sys {\pmv A} \procP 
	\; \bnfmid \; \sys s \gamma 
	\; \bnfmid \; (u)\sysS
	\; \bnfmid \; \sysS \mid \sysS
	\; \bnfmid \; \setenum{\freeze u \contrP}_{\pmv A}
	\\[.8pc]
	
	& \procP \, (\text{Processes})& ::= &  
	\ifte{\expE}{\procP}{\procP}
	\; \bnfmid \; \procX(\vec u,\vec e)
	\; \bnfmid \; \procP \cocoPar \procP
	\\[.5pc]
	& & &
	\bnfmid \; \tellwait{}{\freeze{u} {\contrP}} \cocoSeq \procP
	\; \bnfmid \; \tellretract{}{\freeze{u} {\contrP}} \cocoSeq \procP : \procP
	\\[.5pc]
	& & &
	\bnfmid \; \send u {\atomOut{a} e} \cocoSeq \procP
	\; \bnfmid \; \receive u \langle\;
    	\cocoSum[i]{{\atomIn{a_i} x_i : \sortT_i} \cocoSeq \procP[\!i]} \cocoPlus \tau \cocoSeq \procP 
    	\;\rangle	
	\end{array}
	\]
\end{definition}

\emph{Systems} are the same of \coco, whereas the set of \emph{processes}
is changed and \emph{prefixes} were removed. 

\Cref{fig:co2sub:equiv} shows the new processes defined in terms of \coco.
$\tellwait{}{\freeze{u} {\contrP}} \cocoSeq \procP$ advertise the contract 
$\contrP$ and wait until a new session is established, then the execution 
continue with $\procP$.
%
$\tellretract{}{\freeze{u} {\contrP}} \cocoSeq \procP : \procPi$ advertise the
contract $\contrP$ and wait until a new session is established for a while, then 
the execution continue with $\procP$.
If the timeout expires, the execution continue with $\procPi$ and the session 
cannot longer be established.
%
$\send u {\atomOut{a} e} \cocoSeq \procP$ is the output action and 
$\receive u \langle\; \cocoSum[i]{{\atomIn{a} x : \sortT} \cocoSeq \procP[\!i]} \cocoPlus \tau \cocoSeq \procP\;\rangle$ represent an external choice where $\tau$ models a
timeout in the case no input is received (it can be omitted).


\begin{figure}[t]
	\hrulefill
	\footnotesize
	\[
	\begin{array}{rcl}
	
	\tellwait{}{\freeze{u} {\contrP}} \cocoSeq \procP
	&\equiv&
	(u) (\tell{}{\freeze{u} \contrP} \cocoSeq \ask{u}{true} \cocoSeq \procP)
	
	\\[8pt]
	\tellretract{}{\freeze{u} {\contrP}} \cocoSeq \procP : \procPi
	&\equiv&
	(u) (\tell{}{\freeze{u} \contrP} \cocoSeq 
	( \ask{u}{true} \cocoSeq \procP \cocoPlus \retract{u}{} \cocoSeq \procPi) )
	
	\\[8pt]
	\send u {\atomOut{a} e} \cocoSeq \procP
	&\equiv&
    \fact{u} {\atomOut{a} e} \, \cocoSeq \procP

	\\[8pt]
	\receive u 
	\langle\;
	\cocoSum[i]{{\atomIn{a_i} x_i : \sortT_i} \cocoSeq \procP[\!i]} 
	\cocoPlus \tau \cocoSeq \procP 
    \;\rangle
	&\equiv&
	(\cocoSum[i]{\fact {u} {\atomIn{a_i} x_i : \sortT_i} \cocoSeq \procP[\!i]}) \cocoPlus \tau \cocoSeq \procP
	
	\end{array}
	\]
	\hrulefill
	\vspace{-5pt}
	\caption[]{Structural equivalence for \cocosub processes}
	\label{fig:co2sub:equiv}
	\vspace{-10pt}
\end{figure}


Now we can model a \cocosub agent $\sys{\pmv{A}}{\procP}$ in java.
The abstract class \incodeType{Participant} models the agent and
it provides some utility methods and it relieves the programmer of 
carrying about the middleware details.
We define the function $\sigma : \procP \longrightarrow java$ as follows

\begin{cocomapping}
  
    $\sigma( \tellwait{}{\freeze{u} {\contrP}} \cocoSeq \procP )$ &

\begin{lstlisting}[language=java,mathescape=true,aboveskip=-0.2 \baselineskip]
// 'c' is a Contract defined somewhere
Session u = waitForSession( tell(c) );
$\sigma(\procP)$
\end{lstlisting}

\end{cocomapping}

\begin{cocomapping}

    $\sigma( \tellretract{}{\freeze{u} {\contrP}} \cocoSeq \procP : \procPi ) $ &
%
\begin{lstlisting}[language=java,mathescape=true,aboveskip=-0.2 \baselineskip]
// 'c' is a Contract defined somewhere
// 'delay' is an integer defined somewhere
Public p = tell(c, delay);
try {
    Session session = waitForSession(p);
    $\sigma(\procP)$
} catch(ContractExpiredException e) {
    $\sigma(\procPi)$
}
\end{lstlisting}


\end{cocomapping}

\begin{cocomapping}
   
    $\sigma( \send u {\atomOut{a} e} \cocoSeq \procP ) $ &
%
\begin{lstlisting}[language=java,mathescape=true,aboveskip=-0.2 \baselineskip]
// 'u' is a Session defined somewhere
u.send("a", $e$)
$\sigma(\procP)$
\end{lstlisting}

\end{cocomapping}

\begin{cocomapping}

    $\sigma( \receive u 
    	\langle\;
    	\cocoSum[i] {\atomIn{a_i} x_i : \sortT_i} \cocoSeq \procP[i]
    	\cocoPlus \tau \cocoSeq \procP 
        \;\rangle ) $ &
%
\begin{lstlisting}[language=java,mathescape=true,aboveskip=-0.2 \baselineskip]
// 'u' is a Session defined somewhere
// 'timeout' is an integer defined somewhere
try {
    Message msg = u.waitForReceive(timeout, "a_1", ..., "a_n")
    
    switch(msg.getLabel()) {
    
    case "a_i":
        $\sortT_i$ "x_i" = msg.getValue($\sortT_i$.class);
        $\sigma(\procP[i])$
        break;
    }
    
} catch (TimeExpiredException) {
    $\sigma(\procP)$
}
\end{lstlisting}

\end{cocomapping}

\subsubsection{Honesty Checker in Java}
We also implemented a class \incodeType{HonestyChecker} to verify the
honesty of Java applications. The idea is the reverse of the one in
the previous section: using \textit{Java PathFinder} (JPF) we analyze
the Java bytecode and we build up the \coco process. Then, we
translate the \coco process into a Maude process and we check its honesty.

\tizinote{dire che il check tiene conto dell'invocazione di librerie e terze parti per capire se un'azione verra' fatta davvero}

\subsubsection{Parallel processes}\label{sec:java-parallel}
The \coco parallel process maps directly to a Java
\incodeType{Thread}, which is executed asynchronously with the
callee. We use the method
\incodeMethod{parallel(\incodeType{Runnable})} in order to handle its
invocation and the start of the new thread. The method is
\emph{synchonized}, so there are not overlaps due for example to
multiple threads that try to start a parallel process. In this way,
when handling the call with JPF, we are sure to make the correct
association between the caller and the callee thread.

% The execution is now more complicated due to the scheduling of the
% spawn threads. Fortunately JPF allows to retrieve the thread
% identifier when handling the method calls, so we extend our data
% structure using a map of $\langle thread\, ID,
% \coco{}Stack\rangle$.
% When a new thread starts, it is linked to the caller and each of them
% construct its \coco process independently from the other one.

% \subsubsection{Construction flaws}
% Unfortunately, we do not care about the actions types. This originates
% from the impossibility to specify the contract actions types to the
% middleware and it is not related to other limitations.



