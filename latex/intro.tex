\section{Introduction}

%- cappello introduttivo sulle applicazioni distribuite, e su quali sono i
%rischi correlati (in pratica, i primi due paragrafi in co2-middleware)

Developing modern distributed applications 
is a challenging task:
programmers have to reliably compose loosely-coupled services
which can dynamically discover and invoke other services,
and may be subject to failures and attacks.
These services may be under the governance of mutually distrusting providers 
(possibly competing among each other), 
and interact through open networks, %
where attackers can try to exploit their vulnerabilities. %
%
To guarantee the reliability and security of these applications,
one cannot directly apply standard analysis techniques for programming languages
(like \eg, type systems), 
since they usually need to inspect the code of the whole application,
while under the given assumptions one can only % 
reason about the services under their control. %

A possible countermeasure to these issues is to regulate the interaction
between services through \emph{contracts}.
By advertising a contract, a service commits itself
to stick to a given behavior when he will interact with other services.
In this setting, a service infrastructure acts as a trusted third party, 
which collects all the advertised contracts, and establishes sessions
between participants with compliant ones. %
To incentivize honest behaviour,
the infrastructure monitors all the messages exchanged among services,
and it sanctions those which do not respect their contracts.
These sanctions can be pecuniary compensations,
adaptations of the service binding~\cite{Mukhija2007qos},
or they can decrease the service reputation~\cite{CO2middleware}
in order to marginalize dishonest services in the binding phase.


% \paragraph{Analysing contract-oriented services.}
%Dire che questo paradigma rende possibile degli attacchi (paragrafi a
%partire da "When the SOC middleware detects contract violations..." in
%50-shades-of-honesty). Concludere dicendo che allo stato attuale manca la
%possibilita' di verificare la honesty dalla specifica all'implementazione.

The sanction mechanism of contract-oriented services
% featured by the contract-oriented middleware
allows for a new kind of attacks: 
malicious users can try to exploit possible discrepancies between
the promised and the actual behaviour of a service
in order to make it sanctioned. %
Since these attacks may compromise the service and cause economic damage to its provider,
it is important to detect these vulnerabilities \emph{before} deployment. %
Intuitively, a service is vulnerable if, 
in \emph{some} execution context,
it does \emph{not} respect the contracts it advertises.
This may happen either unintentionally
(because of errors in the service specification, or in its implementation),
or even because of malicious behaviour.
Therefore, to avoid sanctions a service must be able
to respect \emph{all} the contracts it advertises, in \emph{all} possible contexts
--- even those populated by adversaries.
We call this property \emph{honesty}.
Whenever compliance between contracts ensures their deadlock-freedom 
(as for the compliance relations in~\cite{Acciai10coordination,Barbanera10ppdp,Laneve07concur,Rensink07infoco}),
% removed citation to BSZ14concur to save space
then the honesty property is lifted from contracts to services:
systems of honest services are deadlock-free~\cite{BZ15wsfm}.

Some recent works have studied honesty at the specification level, 
using the process calculus \coco for modelling contract-oriented services~\cite{BMSZ15jlamp,BTZ12sacs,BZ15wsfm}.
Practical modelling experience with \coco has shown that writing honest specifications
is not an easy task, especially when a service has to juggle with multiple sessions.
The reason of this difficulty lies in the fact that,
to devise an honest specification, 
a designer has to anticipate all the possible moves of the context,
but at design time he does not yet know in which context his service will be run.
%
Hence, tools to automate the verification of honesty in \coco 
may be of great help.

A further obstacle to the development of honest services is that, 
even if we start from an honest \coco specification, 
it is still possible that honesty is not preserved
when refining the specification into an actual implementation.
%
Analysis techniques for checking honesty at the level of of implementation
are therefore needed in order to develop reliable contract-oriented applications.

\paragraph{Contributions.}

To support programmers in the development of contract-oriented 
applications, we provid a suite of tools (named \emph{Diogenes}) 
with the following features:
\begin{inlinelist}
\item writing \coco specification of services within an Eclipse plugin;
\item verifying honesty of \coco specifications;
\item generating from them skeletal Java programs which
use the contract-oriented APIs of the middleware in~\cite{CO2middleware}; %
\item verifying the honesty of Java programs upon refinement.
\end{inlinelist}
We have validated our tools by applying them to
all the case studies in~\cite{BMSZ15jlamp}:
an online store with bank,
a voucher distribution system,
a car purchase financed with a loan,
an online casino featuring blackjack,
and a travel agency.
We have specified each of these case studies in \coco,
and we have successfully verified the honesty of 
both the specifications and of their Java refinements.
Overall, we can execute these verified services 
using the middleware in~\cite{CO2middleware},
being guaranteed that they will not incur in sanctions,
and they will enjoy deadlock-freedom when interacting 
with other honest services.
Our verification tools, the Eclipse plugin, and an online tutorial about Diogenes
are available at~\url{co2.unica.it/diogenes}.








\endinput 
In \coco we formalize services 
as processes that can advertise contracts with the $\tell{}{}$ primitive,
and realize them with the $\fact{}{}$ primitive. %

\begin{figure}
    \hrulefill
    \scriptsize
    \centering
    \def\arraystretch{1.5}
    \setlength{\tabcolsep}{5pt}
  %  \begin{tabular}{p{4cm}p{7.5cm}} 

    \[\procP \; = \; (x) \; 
    \tell {} {\freeze{x}{\atomIn{a} \sumExt \atomIn{b} \contrSeq \atomOut{c}}} \cocoSeq \;
    \ask{x}\; \cocoSeq \;
   % \fact x {\atomIn{a}} \;\cocoPlus\; 
    \fact x {\atomIn{b}} \;\cocoSeq\; \fact x {\atomOut{c}}
    \]
        
\begin{mdframed}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
Contract c = externalSum()
             .add("a")
             .add("b", internalSum().add("c"));

Public pbl = tell(c);
Session x = pbl.waitForSession();
Message msg = x.waitForReceive("b")
x.sendIfAllowed("c", "value");
\end{minted}
\end{mdframed}
   
    %\end{tabular}
    
    \hrulefill
    \vspace{-5pt}
    \caption{Comparison between \coco specification 
    and corresponding java implementation} \label{fig:comp}
    \vspace{-10pt}
\end{figure}

\Cref{fig:comp} shows how a \coco specification can be implemented in java
using the \coco middleware's API.

The process $\procP$ above advertises the contract 
$\atomIn{a} \sumExt \atomIn{b} \contrSeq \atomOut{c}$ (line \lineno{5}), stating that 
it will receive a message of kind $\atom{a}$ or $\atom{b}$. %
If $\atom{b}$ has been received, then a message of type $\atom{c}$ has to be sent.
When the contract is stipulated,
the middleware creates a new session $x$, 
and then the service waits to receive through that session 
a message of kind $\atomIn{b}$ (line \lineno{7}), then it sends
a message of type $\atom{c}$ (line \lineno{8}). %
The process $\procP$ is \emph{dishonest}: 
indeed, if the other participant involved at session $x$ 
sends a message of kind $\atom{a}$,
then $\procP$ is not going to do the corresponding input. %
Note however that $\procP$ is honest in all 
contexts where either the session $x$ is not created,
or the participant at the other endpoint of session $x$ 
never sends messages of kind $\atom{a}$. %


Another (more involved) example is shown in \Cref{fig:comp2}.

The process $\procP$ advertises two contracts: 
$\atomIn{a}$, which waits for a message of kind $\atom{a}$, 
and $\atomOut{b}$, which  sends a message of kind $\atom{b}$,
respectively on sessions $x$ and $y$. %
When the session $x$ is created, $\procP$ receives a message of kind $\atom{a}$,
and then,  when also $y$ is created, it sends a message of kind $\atom{b}$. %

\begin{figure}
    \hrulefill
    \scriptsize
    \centering
    \def\arraystretch{1.5}
    \setlength{\tabcolsep}{5pt}
  %  \begin{tabular}{p{4cm}p{7.5cm}} 

\[
\procPi\; = \; (x, \, y) \;
\tell {} {\freeze{x}{\atomIn{a}}} \cocoSeq \;
\tell {} {\freeze{y}{\atomOut{b}}} \cocoSeq \;
\ask{x} \cocoSeq \; 
\fact x {\atomIn{a}} \cocoSeq \;
\ask{y} \cocoSeq \;
\fact y {\atomOut{b}}
\]
        
\begin{mdframed}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
Contract c = externalSum().add("a");
Contract d = internalSum().add("b");

Public pbl_x = tell(c);
Public pbl_y = tell(d);

Session x = pbl_x.waitForSession();
Message msg = x.waitForReceive("a")

Session y = pbl_y.waitForSession();
y.sendIfAllowed("b")
\end{minted}
\end{mdframed}
   
    %\end{tabular}
    
    \hrulefill
    \vspace{-5pt}
    \caption{Comparison between \coco specification 
    and corresponding java implementation} \label{fig:comp2}
    \vspace{-10pt}
\end{figure}



Surprisingly enough, the process $\procPi$ is \emph{dishonest},
for two different reasons.
First, in contexts where session $y$ is created and $x$ is not
\footnote{Note that once a contract is published with the $\tell{}{}$ prefix 
(lines \lineno{4} and \lineno{5}), 
it can be fused independently from waiting for a session to be fused using the $\ask{}{}$ prefix
(lines \lineno{7} and \lineno{10}) }, 
the $\fact y {\atomOut{b}}$ cannot be reached 
(and so the contract at session $y$ is not fulfilled).
Second, also in those contexts where both sessions are created,
if the other participant at session $x$ never sends the $\atom{a}$ message,
then $\fact y {\atomOut{b}}$ cannot be reached.


