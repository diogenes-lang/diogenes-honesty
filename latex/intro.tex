\section{Introduction}

%- cappello introduttivo sulle applicazioni distribuite, e su quali sono i
%rischi correlati (in pratica, i primi due paragrafi in co2-middleware)

Modern distributed applications are often composed 
by loosely-coupled services, 
which can dynamically discover and invoke other services
in order to adapt to changing needs and conditions,
and can appear and disappear from the network. %
These services may be under the governance of mutually distrusting providers 
(possibly competing among each other), 
and interact through open networks, %
where attackers can try to exploit their vulnerabilities. %

In the setting outlined above, % in the previous paragraph, 
developing trustworthy services and applications 
can be a quite challenging task:
the problem fits within the area of computer security,
since we have \emph{adversaries} (in our setting, third-party services),
whose exact number and nature is unknown 
(because of openness and dynamicity). %
%
Further, standard analysis techniques for programming languages
(like \eg, type systems) cannot be applied, 
since they usually need to inspect the code of the whole application,
while under the given assumptions one can only % 
reason about the services under their control. %

\subsection*{Contract-oriented computing}
%Dire che parte dei problemi sopra possono essere affrontati usando i
%contratti. Illustrare concisamente cosa fa un contract-oriented
%middleware. Parlare della reputazione.

A possible countermeasure to these issues is to discipline the interaction
between services through \emph{contracts}.
A contract specifies an abstraction of the intended behaviour of a service,
both from the point of view of what it offers to the other services, 
and of what it requires in exchange.
Services \emph{advertise} contracts when they want to offer 
(or sell) some features to clients over the network, or when 
they want to delegate the implementation of some features to some other services.

The communication is managed by a \emph{contract-oriented middleware}
that plays the role of a trusted party collecting
all the advertised contracts and establishing a \textit{session}
between participants whose contracts are compliant. %
The interaction is \textit{monitored} by the middleware, %
which can blame a participant responsible of
a contract violation, and then suitably punish it. 
%
In particular, we focus on the middleware presented in \cite{CO2middleware}.


\subsection*{Analysing contract-oriented services}
%Dire che questo paradigma rende possibile degli attacchi (paragrafi a
%partire da "When the SOC middleware detects contract violations..." in
%50-shades-of-honesty). Concludere dicendo che allo stato attuale manca la
%possibilita' di verificare la honesty dalla specifica all'implementazione.

The sanction mechanism
% featured by the contract-oriented middleware
allows for a new form of attacks: 
malicious users can try
to make some service sanctioned by exploiting possible discrepancies between
the promised and the actual behaviour of that service. %
A crucial problem is then
how to avoid such attacks \emph{before} deploying a service. %

When services behave in the ``right way'' for all the contracts
they advertise,
they are called \emph{honest}. %
Instead, when services are \emph{not} honest,
they do \emph{not} always respect the contracts they advertise,
at least in some execution context. %
This may happen either unintentionally
(because of errors in the service specification, or in its implementation),
or even because of malicious behaviour.
%However, designing an \emph{honest} service which always respects its contracts requires one to fulfil its obligations also in adversarial contexts which play against.

To study honesty at the specification level we can use \coco, 
a core process calculus for contract-oriented 
computing~\cite{BZ10lics,BTZ12sacs}.
%
\hidden{
In \coco we formalize services 
as processes that can advertise contracts with the $\tell{}{}$ primitive,
and realize them with the $\fact{}{}$ primitive. %

\begin{figure}
    \hrulefill
    \scriptsize
    \centering
    \def\arraystretch{1.5}
    \setlength{\tabcolsep}{5pt}
  %  \begin{tabular}{p{4cm}p{7.5cm}} 

    \[\procP \; = \; (x) \; 
    \tell {} {\freeze{x}{\atomIn{a} \sumExt \atomIn{b} \contrSeq \atomOut{c}}} \cocoSeq \;
    \ask{x}\; \cocoSeq \;
   % \fact x {\atomIn{a}} \;\cocoPlus\; 
    \fact x {\atomIn{b}} \;\cocoSeq\; \fact x {\atomOut{c}}
    \]
        
\begin{mdframed}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
Contract c = externalSum()
             .add("a")
             .add("b", internalSum().add("c"));

Public pbl = tell(c);
Session x = pbl.waitForSession();
Message msg = x.waitForReceive("b")
x.sendIfAllowed("c", "value");
\end{minted}
\end{mdframed}
   
    %\end{tabular}
    
    \hrulefill
    \vspace{-5pt}
    \caption{Comparison between \coco specification 
    and corresponding java implementation} \label{fig:comp}
    \vspace{-10pt}
\end{figure}

\Cref{fig:comp} shows how a \coco specification can be implemented in java
using the \coco middleware's API.

The process $\procP$ above advertises the contract 
$\atomIn{a} \sumExt \atomIn{b} \contrSeq \atomOut{c}$ (line \lineno{5}), stating that 
it will receive a message of kind $\atom{a}$ or $\atom{b}$. %
If $\atom{b}$ has been received, then a message of type $\atom{c}$ has to be sent.
When the contract is stipulated,
the middleware creates a new session $x$, 
and then the service waits to receive through that session 
a message of kind $\atomIn{b}$ (line \lineno{7}), then it sends
a message of type $\atom{c}$ (line \lineno{8}). %
The process $\procP$ is \emph{dishonest}: 
indeed, if the other participant involved at session $x$ 
sends a message of kind $\atom{a}$,
then $\procP$ is not going to do the corresponding input. %
Note however that $\procP$ is honest in all 
contexts where either the session $x$ is not created,
or the participant at the other endpoint of session $x$ 
never sends messages of kind $\atom{a}$. %


Another (more involved) example is shown in \Cref{fig:comp2}.

The process $\procP$ advertises two contracts: 
$\atomIn{a}$, which waits for a message of kind $\atom{a}$, 
and $\atomOut{b}$, which  sends a message of kind $\atom{b}$,
respectively on sessions $x$ and $y$. %
When the session $x$ is created, $\procP$ receives a message of kind $\atom{a}$,
and then,  when also $y$ is created, it sends a message of kind $\atom{b}$. %

\begin{figure}
    \hrulefill
    \scriptsize
    \centering
    \def\arraystretch{1.5}
    \setlength{\tabcolsep}{5pt}
  %  \begin{tabular}{p{4cm}p{7.5cm}} 

\[
\procPi\; = \; (x, \, y) \;
\tell {} {\freeze{x}{\atomIn{a}}} \cocoSeq \;
\tell {} {\freeze{y}{\atomOut{b}}} \cocoSeq \;
\ask{x} \cocoSeq \; 
\fact x {\atomIn{a}} \cocoSeq \;
\ask{y} \cocoSeq \;
\fact y {\atomOut{b}}
\]
        
\begin{mdframed}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
Contract c = externalSum().add("a");
Contract d = internalSum().add("b");

Public pbl_x = tell(c);
Public pbl_y = tell(d);

Session x = pbl_x.waitForSession();
Message msg = x.waitForReceive("a")

Session y = pbl_y.waitForSession();
y.sendIfAllowed("b")
\end{minted}
\end{mdframed}
   
    %\end{tabular}
    
    \hrulefill
    \vspace{-5pt}
    \caption{Comparison between \coco specification 
    and corresponding java implementation} \label{fig:comp2}
    \vspace{-10pt}
\end{figure}



Surprisingly enough, the process $\procPi$ is \emph{dishonest},
for two different reasons.
First, in contexts where session $y$ is created and $x$ is not
\footnote{Note that once a contract is published with the $\tell{}{}$ prefix 
(lines \lineno{4} and \lineno{5}), 
it can be fused independently from waiting for a session to be fused using the $\ask{}{}$ prefix
(lines \lineno{7} and \lineno{10}) }, 
the $\fact y {\atomOut{b}}$ cannot be reached 
(and so the contract at session $y$ is not fulfilled).
Second, also in those contexts where both sessions are created,
if the other participant at session $x$ never sends the $\atom{a}$ message,
then $\fact y {\atomOut{b}}$ cannot be reached.
}
%
The problem of verifying honesty is not trivial, 
also because one must consider \emph{all} possible execution contexts, 
which are infinite. %
Indeed, honesty of \coco processes is \emph{not} decidable, as shown 
in~\cite{Bartoletti15wsfm}. %
Verifying honesty is only possible in non Turing-powerful fragments of \coco,
for instance the one where processes are essentially finite-state,
i.e.\ they have neither delimitation nor parallel under process definitions. %
In this case, it is possible to verify honesty 
by using the model-checking technique of~\cite{verifiable}. %

A further issue is that, 
even if we assume an honest \coco specification, 
it is still possible that honesty no longer holds 
when refining the specification into an actual implementation 
(e.g.\ a Java program using the middleware APIs of~\cite{CO2middleware}). %
% the risk of incurring a sanction at runtime, so preserving the reputation.
% we still need to verify that the corresponding implementation is honest, too. %
% reducing 
%
With the existing techniques developed for \coco, 
one can only check honesty at the level of specification:
this requires a developer to
write a \coco process in the Maude language~\cite{Maude01},
and then by to apply there the model-checking tool of~\cite{verifiable}. %
% However, this is not enough, because errors could be introduced in the implementation, which could break the property.
Analysis techniques for checking honesty at the level of of implementation
are therefore needed in order to develop secure contract-oriented applications.

\subsection*{Contributions}

We support programmers on the development of contract-oriented 
applications, providing:
1) an Eclipse plugin that allows to write a \coco specification of the service,
to verify its honesty, and generate a skeletal Java program;
2) Diogenes, the tool to verify that the honesty has not been compromised
by the refinement of the specification.

