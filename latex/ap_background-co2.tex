

\section{Session types as contracts} \label{sec:contract-session-types}\label{sec:background}


\subsection{Syntax}


\subsection{Semantics}

While a contract describes the intended behaviour of \emph{one} of the two participants involved in a session, the behaviour of two interacting participants {\pmv A} and {\pmv B} is modelled by the composition of two contracts, denoted by $\bic{\contrP}{\contrQ}$.
We specify in~\Cref{def:contracts:semantics} an operational semantics of contracts, where the two participants alternate in firing actions. To do that, we extend the syntax of~\Cref{def:contracts:syntax} with the term $\ready{\atomIn{a}\val{v}} \contrSeq \contrP$, which models a participant ready to input a value $\valV$ in a branch with label $\atom{a}$, and then to continue as $\contrP$.
In other words, $\ready{\atomIn{a}\val{v}}$ acts as a one-position buffer shared between the two participants.

\begin{definition}[Semantics of contracts]\label{def:contracts:semantics}
A \emph{contract configuration} $\gamma$ is a term of the form $\bic{\contrP}{\contrQ}$,
where $\pmv A \!\neq\! \pmv B$ and
the syntax of contracts is extended with terms 
$\ready{\atomIn{a}\val{v}} \contrSeq \contrP$.
We postulate that at most one occurrence of $\ready{}$ is present,
and if so $\ready{}$ is at the top-level.
We define a congruence relation $\equiv$ between contracts
as the least equivalence including
$\alpha$-conversion of recursion variables, and satisfying
$\rec{\contrX}{\contrP} \equiv \contrP \setenum{\bind{\contrX}{\rec{\contrX}{\contrP}}}$.
% $\SumInt[i \in \emptyset]{\atomIn[i]{a}\sort{T}}{c_i} \equiv 
%  \SumExt[i \in \emptyset]{\atomOut[i]{a}\sort{T}}{c_i}$,
Also, we assume that 
$\bic{\contrP}{\contrQ}$ is equivalent to $\pbic{B}{\contrQ}{A}{\contrP}$.
The semantics of contracts
is modelled by a the labelled transition relation $\cmove{}$,
which is the smallest relation closed under the rules 
in~\Cref{fig:contracts:semantics} and under~$\equiv$. %
We denote with $\cmove{}^*$ the reflexive
and transitive closure of $\cmove{}$. %
A \emph{computation} (of an initial configuration $\gamma_0$)
is a possibly infinite sequence of transitions
$\gamma_0 \cmove{} \gamma_1 \cmove{} \cdots$. %
\end{definition}

\begin{figure}[t]
\footnotesize\selectfont
\hrulefill
\[
\begin{array}{rcll}
  \bic
  {(\sumI{\atomOut{a}\sortT}{\contrP} \sumInt \contrPi)}
  {(\sumE{\atomIn{a}\sortT}{\contrQ} \sumExt \contrQi)}
   & \cmove{{\pmv A} \says \atomOut{a}\valV} &
   \bic{\contrP}{\ready{\atomIn{a}\valV} \contrSeq \contrQ}
   & 
   \text{if }\; \valV: \sortT
   \qquad
   \nrule{[IntExt]}
\\[8pt]
  \bic{\ready{\atomIn{a}\valV} \contrSeq \contrP}{\contrQ}
   & \cmove{{\pmv A} \says \atomIn{a}\valV} &
   \bic{\contrP}{\contrQ}
   & 
   \phantom{\text{if }\; \valV: \sortT}
   \qquad
   \nrule{[Rdy]}
\end{array} 
\]
\hrulefill
\vspace{-10pt}
\caption[Semantics of contracts]{Semantics of contracts (symmetric rules for $\pmv B$ actions omitted)}
\label{fig:contracts:semantics}
\end{figure}

In rule~\nrule{[IntExt]}, {\pmv A} can perform any of the actions in the intersection between its internal sum labels, and the external sum labels of {\pmv B}; then, {\pmv B} is forced to commit to the corresponding branch in its external sum.
This is done by marking such a committed branch with $\ready{\atomIn{a}\val{v}}$, while discarding all the other branches; the transition label ${\pmv A} \says \atomOut{a}\val{v}$ models {\pmv A} selecting the branch with label $\atom{a}$, and passing value $\val{v}$.
Participant {\pmv B} can then perform his action in the subsequent step, by rule~\nrule{[Rdy]}. 
%
Note that this semantics causes an \emph{alternation} between 
output and input actions,
not present in other semantics of sessions types 
(for instance, the one in \cite{Barbanera10ppdp}).
%
This alternation allows for a ``contractual'' interpretation 
of session types:
when a transition with label $\lbl A {\cdots}$ is enabled, 
it means that $\pmv A$ is in charge to perform the next contractual action. %
In particular, $\pmv A$ is in charge either when she has an internal choice, %
or she is committed to a branch of
an external choice (with $\ready{}$). %
Observe that this interpretation would not fit % with a semantics 
with standard CCS-style synchronisation, since the latter %
% blurs the distinction between input and output actions. %
does not allow to distinguish $\pmv{A}$'s turn in sending
from %
and $\pmv{B}$'s turn in receiving.

\subsection{Compliance} \label{sec:contracts:compliance}
We now define a notion of compliance between contracts. The intuition is that if a contract $\contrP$ is compliant with a contract $\contrQ$, 
then in all the configurations of a computation of $\bic{\contrP}{\contrQ}$,
whenever a participant wants to choose a branch in an internal sum, 
the other participant always offers the opportunity to do it.
Compliance guarantees that % \emph{progress}: 
whenever a computation of $\bic{\contrP}{\contrQ}$ becomes stuck,
then both participants have reached the success state $\cnil$.

\begin{definition}[Compliance] 
  \label{def:compliance}
  % \label{def:contracts:rdy} 
  We say that a configuration $\gamma$ is \emph{safe} iff
  either:
  \[
  \begin{array}{lrllclr}
    &\text{(i)}&%
    \gamma = 
    % \displaystyle
    \bic
    {\SumInt[i \in I]{\atomOut[i]{a}\sortT[i]}{\contrP[i]}}
    {\SumExt[j \in J]{\atomIn[j]{a}\sortT[j]}{\contrQ[j]}}
    & \text{ with } &
    \emptyset \neq I \subseteq J
    % \text{ and } (\mathcal{I} = \emptyset \implies \mathcal{J} = \emptyset)
    \\[10pt]
    \text{ or }%
    &\text{(ii)}&%
    \gamma = \bic{\ready{\atomIn{a}\valV}.\, \contrP}{\contrQ} & & & 
    \\[10pt]
    \text{ or } %
    &\text{(iii)}&%
    \gamma = \bic{\cnil}{\cnil} & & & 
  \end{array}
  \]
  Then, we say that $\contrP$ and $\contrQ$ are compliant 
  (in symbols, $\contrP \compliant \contrQ$)
  whenever:
  \[
  % \forall \gamma .\ 
  \bic{\contrP}{\contrQ}
  \;\cmove{}^*\;
  \gamma
  \;\;\implies\;\;
  \gamma \text{ safe}
  \]
\end{definition}

We observe that the notion of compliance in~\Cref{def:compliance}
is equivalent to that of \emph{progress} in~\cite{Barbanera10ppdp,BartolettiSZ14Concur}.
This can be proved as in~\cite{BCPZ15jlamp},
by exploiting the fact that the alternating semantics of session types is 
\emph{turn-bisimilar} to the standard LTS semantics
(as shown in Lemma 5.10 in~\cite{BCPZ15jlamp}).  %

\begin{example} \label{ex:contracts:1}
Let $\gamma = \bic{\contrP}{\contrQ}$, 
where $\contrP = \sumI{\atomOut{a}}{\contrP[1]} \sumInt \sumI{\atomOut{b}}{\contrP[2]}$ 
and $\contrQ = \sumE{\atomIn{a}}{\contrQ[1]} \sumExt \sumE{\atomIn{c}}{\contrQ[2]}$.
If participant {\pmv A} internally chooses label $\atom{a}$, 
then $\gamma$ will take a transition to 
\(
  {\pmv A} \says \contrP[1] \mid {\pmv B} \says \ready{\atomIn{a}\valV}.\ \contrQ[1]
\),
for some $\valV$.
Suppose instead that {\pmv A} chooses $\atom{b}$, 
which is not offered by {\pmv B} in his external choice.
In this case, $\gamma \not\cmove{\pmv A \says \atomOut{b}\valV}$,
and indeed $\gamma$ is \emph{not} safe according to~\Cref{def:compliance}.
Therefore, $\contrP$ and $\contrQ$ are \emph{not} compliant.
\end{example}


The following lemma states that each contract has a compliant one.

\newcommand{\lemproperhascompliant}{
For all contracts $\contrP$,
there exists some $\contrQ$ such that $\contrP \compliant \contrQ$.}
\begin{lemma} 
\label{lem:proper-has-compliant}
\label{lem:compliant-dual}
\lemproperhascompliant
\end{lemma}


\begin{figure}[t]
\footnotesize\selectfont
\hrulefill
\[
\begin{array}{rcll}
  \bic
  {(\sumI{\vabsatomA}{\contrP} \sumInt \contrPi)}
  {(\sumE{\co{\vabsatomA}}{\contrQ} \sumExt \contrQi)}
   & \vabscmove{{\pmv A} \says \vabsatomA} &
   \bic{\contrP}{\ready{\co{\vabsatomA}} \contrSeq \contrQ}
   & 
   \nrule{[AbsIntExt]}
\\[8pt]
  \bic{\ready{\vabsatomA} \contrSeq \contrP}{\contrQ}
   & \vabscmove{{\pmv A} \says \vabsatomA} &
   \bic{\contrP}{\contrQ}
   &
   \nrule{[AbsRdy]}
\end{array} 
\]
\hrulefill
\vspace{-10pt}
\caption[Semantics of value-abstract contracts]{Semantics of value-abstract contracts (symmetric rules for $\pmv B$ actions omitted)}
\label{fig:contracts:vabs-semantics}
\end{figure}


\Cref{def:compliance} cannot be directly exploited as an
algorithm for checking compliance,
as the transition system of contracts is infinite state
(and infinitely branching),
because of values $\valV$ in transition labels and in states. 
However, note that values do not play any role in the dynamics of contracts,
except for their occurrence in transition labels
(which will be exploited later on in~\Cref{sec:co2}).
% to define a value-passing semantics of \coco.
Therefore, for the sake of checking compliance we can consider
an alternative semantics of contracts, where we abstract from values
(\Cref{fig:contracts:vabs-semantics}).
The configurations in this semantics are terms of the form
$\bic{\vabs{\contrP}}{\vabs{\contrQ}}$, 
where the abstraction $\vabs{}$ encodes sorts in branch labels,
and removes values from $\ready{}$.
For instance, $\atomOut{a}\sortT.\,\contrP$ is abstracted as
$(\atom{a},\sortT)\bang.\,\vabs{\contrP}$,
while $\ready{\atomIn{a}\valV}.\,\contrP$ is abstracted as
$\ready{(\atom{a},\sortT)\qmark}.\,\vabs{\contrP}$ 
whenever $\valV: \sortT$.
The branch labels of value-abstract contracts
(ranged over by $\vabsatomA, \vabsatomB, \ldots$)
are terms of the form $(\atom{a},\sortT)\circ$,
where $\circ \in \setenum{\bang,\qmark}$.
We postulate an involution operator $\co{\cdot}$ of value-abstract
branch labels, satisfying
$\co{\atomIn{(a,\sortT)}} = \atomOut{(a,\sortT)}$ and
$\co{\atomOut{(a,\sortT)}} = \atomIn{(a,\sortT)}$.

\smallskip
The semantics of value-abstract contracts leads to a finite state system, 
so it provides us with 
a model-checkable characterisation of compliance.

\newcommand{\lemcompliantfail}[0]{%
For all contracts $\contrP$, $\contrQ$: %
\[%
  \contrP \compliant \contrQ%
  \;\iff\;%
  \left(%
    \forall \gamma .\ %
    \bic{\vabs{\contrP}}{\vabs{\contrQ}}%
    \vabscmove{}^* %
    \gamma %
    \;\implies\;%
    \gamma \text{ safe}
  \right)%
\]%
}%
\begin{lemma} \label{lem:compliant-fail}
\lemcompliantfail%
\end{lemma}

\subsection{Culpability}

We now tackle the problem of determining who is expected
to make the next step in an interaction.
We call a participant {\pmv A} \emph{culpable} in $\gamma$ if
she is expected to perform some actions so to make $\gamma$ progress.
% Despite what the terminology may suggest, 
Note that culpability does not imply a permanent status of 
contract configurations;
instead, it is a \emph{transient} notion, 
because (as formally stated in~\Cref{th:compliant-smiley}),
a participant can always move out from this state. %
% We have opted to stick to this terminology for coherence with~\cite{BTZ12coordination}.}

\begin{definition}[Culpability] \label{def:culpable}
A participant $\pmv A$ is culpable in $\gamma$
($\cfrown{\pmv A}{\gamma}$ in symbols) iff
\(
  \gamma \cmove{{\pmv A} \says \atom{a} \circ \valV}
\)
for some $\atom{a}, \valV$ and $\circ \in \setenum{\bang,\qmark}$.
When $\pmv A$ is \emph{not} culpable in $\gamma$ 
we write $\csmiley{\pmv A}{\gamma}$.
\end{definition}

\Cref{th:unique-culpable} below establishes that,
when starting from a configuration of compliant contracts,
exactly one participant is culpable in all subsequent configurations.
The only exception is
$\bic {\cnil}{\cnil}$, which represents a successfully terminated interaction,
where nobody is culpable.

\newcommand{\thuniqueculpable}{
  Let $\contrP \compliant \contrQ$.
  If $\bic{\contrP}{\contrQ} \cmove{}^* \gamma$, 
  then either $\gamma = \bic{\cnil}{\cnil}$, 
  or there exists a unique culpable in $\gamma$.
}
\begin{theorem}[Unique culpable] \label{th:unique-culpable}
  \thuniqueculpable
\end{theorem}

The following theorem states that a participant is always able
to recover from culpability by performing a bounded number of actions. 
% This requires at most two steps.

\newcommand{\thcompliantsmiley}{
  Let $\gamma = \bic{\contrP}{\contrQ}$, and let
  % with $\contrP \compliant \contrQ$. 
  $\gamma \cmove{}^* \gammai$.
  Then:
  \begin{enumerate}
    
  \item \( 
    \gammai \not\cmove{} 
    \;\implies\; 
    \csmiley{\pmv A}{\gammai} \text{ and } \csmiley{\pmv B}{\gammai}
    \)
    
  \item \(
    \cfrown{\pmv A}{\gammai} 
    \;\implies\; 
    \forall \gammaii : \gammai \cmove{} \gammaii 
    \; \implies \;
    \begin{cases}
      \csmiley{\pmv A}{\gammaii} \text{, or} \\
      \forall \gammaiii : \gammaii \cmove{} \gammaiii \implies \csmiley{\pmv A}{\gammaiii}
    \end{cases}
    \)
    
  \end{enumerate}
}
\begin{theorem}[Contractual exculpation]\label{th:compliant-smiley}
  \thcompliantsmiley
\end{theorem}

Item (1) of~\Cref{th:compliant-smiley} says that no participant is culpable
in a stuck configuration.
Item (2) says that if $\pmv{A}$ is culpable, then she can always
exculpate herself in \emph{at most} two steps: %
one step % is required
if $\pmv{A}$ has an internal choice, or a $\ready{}$ followed by an
external choice; %
two steps % are necessary
if $\pmv{A}$ has a $\ready{}$ followed by an internal choice.

\section{The \coco calculus}\label{sec:co2}
We model agents and systems in the process calculus 
\coco\cite{BZ10lics,BTZ12coordination,BSTZ13forte},
which we instantiate with the contracts introduced in \Cref{sec:contract-session-types}.
In~\Cref{sec:co2:syntax} we provide the syntax of \coco:
its primitives allow agents to advertise contracts, 
to open sessions between agents with compliant contracts, 
to fulfil them by performing the required actions,
and to query contracts.
Then, in~\Cref{sec:co2:semantics} we define the semantics of \coco,
and in~\Cref{sec:co2:honesty} we formalise the concept of honesty.

\subsection{Syntax}\label{sec:co2:syntax}
Let $\vars$ and $\snames$ be disjoint sets
of \emph{variables} (ranged over by $x,y,\ldots$) and 
\emph{names} (ranged over by $s,t,\ldots$).
%
We assume a language of \emph{expressions}
(ranged over by $\expE, \expEi, \ldots$),
containing variables, values, and operators 
(\eg the usual arithmetic/logic ones).
The actual choice of operators is almost immaterial for the
subsequent technical development; here we just postulate
a function $\sem{\cdot}$ which maps (closed) expressions to values.
We assume that the sort of an expression is uniquely determined 
by the sorts of its variables.
We use $u,v,\ldots$ to range over $\vars \cup \snames$,
we use $\vec{u},\vec{v},\ldots$ to range over 
sequences of variables/names, and
$\vec{e}$ to range over sequences of expressions.
To make symbols lookup easier, we have summarised the syntactic categories 
and some notation in Table~\ref{def:notation}.
% Some of the symbols defined therein will only be used in later sections.

\begin{table}[t]
	\footnotesize
	\hrulefill
	% \vspace{-10pt}
	\[
	\begin{array}{ll}
	
	\begin{array}{ll}
	\pmv{A}, \pmv{B}, \ldots & \text{Participant names}
	\\
	\atom{a}, \atom{b}, \ldots & \text{Branch labels}
	\\
	\sortT, \sortTi, \ldots & \text{Sorts}
	\\
	\valV, \valVi, \ldots & \text{Values}
	\\
	\contrP, \contrQ, \ldots & \text{Contracts}
	\\
	\gamma, \gammai, \ldots & \text{Contract configurations} 
	\\
	%   \contrP \compliant \contrQ & \text{Compliance}
	%   \\
	%   \cfrown{\pmv A}{\gamma} & \text{Culpability}
	%   \\
	\gamma \cmove{} \gammai & \text{Transition of contracts}
	\end{array}
	
	& \hspace{18pt}
	
	\begin{array}{ll}
	u, v,\ldots \mbox{\hspace{50pt}} & \text{Union of:} 
	\\
	s,t, \ldots \in \snames & \text{Session names} 
	\\
	x, y, \ldots \in \vars & \text{Variables} 
	\\
	\expE, \expEi, \ldots & \text{Expressions} 
	\\
	\procP,\procQ,\ldots & \text{Processes} 
	\\
	\sysS, \sysSi,\ldots & \text{Systems}
	\\
	%   \vabscontrP, \vabssysS, \ldots & \text{Value-abstract contracts/systems}
	%   \\
	%   \cabscontrP, \abssysS, \ldots & \text{Context-abstract contracts/systems}
	%   \\
	\sysS \pmove{} \sysSi & \text{Transition of systems}
	\end{array}
	
	\end{array}
	\]
	\hrulefill
	\vspace{-5pt}
	\caption{Summary of notation.} \label{def:notation}
\end{table}


\begin{definition}\label{def:co2:syntax}
	The syntax of \coco is defined as follows:
	\[
	\small
	\begin{array}{r@{\hskip 0.1cm}lclcccccccccccc}   
	& \sysS \, (\text{Systems}) & ::= & 
	\emptysys 
	~\bnfmid ~ \sys {\pmv A} \procP 
	\; \bnfmid \; \sys s \gamma 
	\; \bnfmid \; (u)\sysS
	\; \bnfmid \; \sysS \mid \sysS
	\; \bnfmid \; \setenum{\freeze u \contrP}_{\pmv A}
	\\[.8pc]
	
	& \procP \, (\text{Processes})& ::= &  \textstyle 
	\cocoSum[i]{\pref[i] \cocoSeq \procP[\!i]}
	\; \bnfmid \; \ifte{\expE}{\procP}{\procP}
	\; \bnfmid \; \procX(\vec u,\vec e)
	\; \bnfmid \; (u)\procP
	\; \bnfmid \; \procP \cocoPar \procP
	\\[.8pc]
	
	& \pref \, (\text{Prefixes})& ::= & \tau
	\; \bnfmid \; \tell {} {\freeze u \contrP}
	\; \bnfmid \; \fact u {\atomOut{a} e}
	\; \bnfmid \; \fact u {\atomIn{a} x : \sortT}
	\; \bnfmid \; \ask {u} {\!\phi}
	\end{array}
	\]
	If $\vec u = u_0,\hdots,u_n$,
	we will use $(\vec u) \sysS$ and $(\vec u) \procP$ 
	as shorthands for $(u_0)\cdots(u_n) \sysS$ and $(u_0)\cdots(u_n) \procP$,
	respectively. %
	We also assume the following syntactic constraints on processes and systems:
	\begin{enumerate}
		
		\item each occurrence of named processes is prefix-guarded;
		
		\item in $(\vec u)(\sys {\pmv A} \procP \mid \sys{\pmv B} \procQ \mid \cdots)$,
		it must be $\pmv A \neq \pmv B$;
		
		\item in $(\vec u)(\sys s \gamma \mid \sys t \gammai \mid \cdots)$,
		it must be $s \neq t$.
		
	\end{enumerate}
\end{definition}


\begin{figure}[t]
	\hrulefill
	\footnotesize
	\begin{center}
		commutative monoidal laws for $\mid$ on processes and systems
	\end{center}
	\vspace{-10pt}
	\[
	\begin{array}{c}
	\sys {\pmv A} {(v) \procP} \equiv \sys{(v) \, {\pmv A}} \procP 
	\hspace{20pt}
	\sysFmt{Z} \mid (u) \sysFmt{Z'} \equiv (u)(\sysFmt{Z} \mid \sysFmt{Z'}) 
	\;\;\text{if}\ u \not\in \fv{\sysFmt{Z}} \cup \fn{\sysFmt{Z}}
	\\[8pt]
	(u)(v) \sysFmt{Z} \equiv (v)(u) \sysFmt{Z}
	\hspace{20pt}
	(u) \sysFmt{Z} \equiv \sysFmt{Z}
	\;\;\text{if}\ u \not\in \fv{\sysFmt{Z}} \cup \fn{\sysFmt{Z}}
	\hspace{20pt} 
	\setenum{\freeze s \contrP}_{\pmv A} \equiv \pnil 
	\end{array}
	\]
	\hrulefill
	\vspace{-5pt}
	\caption[Structural equivalence for \coco]{Structural equivalence for \coco 
		($\sysFmt{Z},\sysFmt{Z'}$ range over systems or processes).} \label{fig:co2:equiv}
	\vspace{-10pt}
\end{figure}


\emph{Systems} $\sysS, \sysSi,\ldots$ are the parallel composition of 
\emph{participants} $\sys {\pmv A} \procP$,
\emph{sessions} $\sys s \gamma$,
\emph{delimited systems} $(u)\sysS$, 
and \emph{latent contracts} $\setenum{\freeze{u\!\!}{\contrP}}_{\pmv A}$.
A latent contract $\setenum{\freeze{x\!\!}{\contrP}}_{\pmv A}$ 
represents a contract $\contrP$ (advertised by {\pmv A}) which
has not been stipulated yet; upon stipulation, the variable $x$ will be
instantiated to a fresh session name. 
% Latent contracts of the form 
% $\setenum{{\freeze s c}_{\pmv A}}$, where $s$ is a session \emph{name} are discarded
% by the axiom $\setenum{{\freeze s c}_{\pmv A}} \equiv \pnil$ in~\Cref{fig:co2:equiv}.

\emph{Processes} $\procP, \procQ, \ldots$ are
prefix-guarded (finite) sums of processes,
conditionals $\ifte{\expE}{\procP}{\procQ}$
(where $\expE$ is a boolean valued expression),
named processes $\procX(\vec u,\vec e)$ %
(used \eg\ to specify recursive behaviours),
delimited processes $(u) \procP$,
and parallel compositions $\procP \cocoPar \procP$.

\emph{Prefixes} $\pref$ include silent action $\tau$, 
contract advertisement $\tell{}{\freeze u \contrP}$, 
output action $\fact{u}{\atomOut{a}\expE}$,
input action $\fact{u}{\atomIn{a}x:\sortT}$,
and contract query $\ask{u}{\phi}$
(where $\phi$ is an LTL formula on $\gamma$).
%
In each prefix $\pref \neq \tau$, 
the index $u$ refers to the target session involved in
the execution of $\pref$.

\smallskip
The only binder for names is the
delimitation $(u)$, both in systems and processes.
Instead, variables have two binders:
delimitations $(x)$ (both in systems and processes),
and input actions.
Namely, in a process $\fact u {\atomIn{a}x}:\sortT.\, \procP$, 
the variable $x$ in the prefix binds the occurrences of $x$ within $\procP$.
Note that ``value-kinded'' variables in input actions 
will be replaced by values,
while ``name-kinded'' variables used in delimitations 
will be replaced by session names.
Accordingly, we avoid confusion between these two kinds of variables.
For instance, we forbid
$\fact{u}{\atomIn{a}x}.\, \fact{x}{\atomOut{b}{\valV}}$
and
$(x) \, \fact{u}{\atomOut{a}{x}}$.
%
% We assume that the variables used in input actions are disjoint from 
% those used in delimitations.

Free \emph{session} names/variables in a prefix are defined as follows:
$\fnv{\tau} = \emptyset$, and
\(
\fnv{\tell{}{\freeze u \contrP}} = 
\setenum{u} = 
\fnv{\fact u {\atomOut a}\expE} =
\fnv{\fact u {\atomIn a}x:\sortT}
\).
Free variables/names of systems/processes are defined accordingly, 
and they are denoted by $\fv{}$ and $\fn{}$.
A system or a process is \emph{closed} when it has no free variables.

We write $\pref[1] \cocoSeq \procP[1] \cocoPlus \pref[2] \cocoSeq
\procP[2]$ for $\cocoSum[{i \in \setenum{1,2}}] {\pref[i]} \cocoSeq
\procP[i]$, and $\pnil$ for $\cocoSum[{\emptyset}]\procP$.
%
We stipulate that each process identifier $\procX$ 
has a unique defining equation
$\procX(x_1, \ldots, x_j) \mmdef \procP$ such that $\fv{\procP} \subseteq
\setenum{x_1,\ldots,x_j} \subseteq \vars$.
We will sometimes omit %
the arguments of $\procX(\vec u, \vec e)$ when they are clear from the context.
As usual, we omit trailing occurrences of~$\pnil$ in processes.





\subsection{Semantics}\label{sec:co2:semantics}

The operational semantics of \coco\ systems is formalised 
by the labelled transition relation $\pmove{}$ in~\Cref{fig:co2:semantics}, 
where we consider processes and systems up-to the congruence relation $\equiv$
in~\Cref{fig:co2:equiv}. 
The axioms for $\equiv$ are fairly standard ---
except the bottom-rightmost one: it collects garbage terms possibly arising from 
variable substitutions. %
% (more details in~\Cref{ex:car-loan}).
% bartnote: imprecise in the value-passing case
% where  
The labels $\mu$ of the transition relation can be of the following forms:
$\lbl A {\pref}$ (where $\pref$ is not $\fact{}{\!}$),
$\lbl A {\cond}$,
$\lbl A {\fact s {\atomOut{a} \valV}}$,
$\lbl A {\fact s {\atomIn{a} \valV}}$, or
$\lbl K {\fuse{}}$.


\begin{figure}[t]
	\hrulefill
	\small
	\[
	\begin{array}{cl}
	{\sys {\pmv A} {\tau \cocoSeq \procP \cocoPlus \procPi \cocoPar \procQ}
		\;\pmove{\lbl A {\tau}}\;
		\sys {\pmv A} {\procP \cocoPar \procQ}
	} & \nrule{[Tau]}
	\\[10pt]
	{\sys {\pmv A} {\tell {} {\freeze u \contrP} \cocoSeq \procP \cocoPlus \procPi \cocoPar \procQ}
		\;\pmove{\lbl A {\tell {} {\freeze u \contrP}}}\;
		\sys {\pmv A} {\procP \cocoPar \procQ} \ \mid\ 
		\setenum{\freeze u \contrP}_{\pmv A}
	} & \nrule{[Tell]}
	\\[10pt]
	\irule
	{\contrP \compliant \contrQ \qquad \gamma = \bic{\contrP}{\contrQ} 
		\qquad \sigma = \setenum{\bind {x,y} s}
		\qquad s\text{ fresh}
	}
	{(x,y)(\sysS\ \mid\ 
		\setenum{\freeze x \contrP}_{\pmv A}\ \mid\ 
		\setenum{\freeze y \contrQ}_{\pmv B})
		\;\pmove{\lbl K {\fuse{}}}\;
		(s)(\sysS\sigma \ \mid\ \sys s {\gamma})
	} \hspace{15pt} & \nrule{[Fuse]}
	\\[14pt]
	{\sys {\pmv A} {(\ifte{\expE}{\procP_{\true}}{\procP_{\false}}) \cocoPar \procQ}
		\;\pmove{\lbl A {\cond}}\;
		\sys {\pmv A} {\procP_{\scriptsize \sem{\expE}} \cocoPar \procQ}
	} & \nrule{[If]}
	\\[10pt]
	\irule
	{\sem{e} = \valV \qquad
		\gamma \cmove{{\pmv A} \says {\atomOut{a}\valV}} \gammai}
	{\sys {\pmv A} {\fact s {\atomOut{a} e} \cocoSeq \procP \cocoPlus \procPi \cocoPar \procQ}
		\ \mid \ 
		\sys s {\gamma} 
		\;\pmove{\lbl A {\fact s {\atomOut{a} \valV}}}\; 
		\sys {\pmv A} {\procP \cocoPar \procQ}
		\ \mid \ 
		\sys s {\gammai} 
	} & \nrule{[Do$\bang$]}
	\\[14pt]
	\irule
	{\gamma \cmove{{\pmv A} \says {\atomIn{a}\valV}} \gammai \qquad
		\valV: \sortT}
	{\sys {\pmv A} {\fact s {\atomIn{a} x:\sortT} \cocoSeq \procP \cocoPlus \procPi \cocoPar \procQ}
		\ \mid \ 
		\sys s {\gamma} 
		\;\pmove{\lbl A {\fact s {\atomIn{a} \valV}}}\; 
		\sys {\pmv A} {\procP\setenum{\bind{x}{\valV}} \cocoPar \procQ}
		\ \mid \ 
		\sys s {\gammai} 
	} & \nrule{[Do$\qmark$]}
	\\[14pt]
	\irule
	{\gamma \vdash \phi}
	{\sys {\pmv A} {\ask {s} \phi \cocoSeq \procP \cocoPlus \procPi \cocoPar \procQ} \ \mid\ 
		\sys s \gamma
		\;\pmove{\lbl A {\ask s \phi}}\;
		\sys {\pmv A} {\procP \cocoPar \procQ} \ \mid\ \sys s \gamma
	} & \nrule{[Ask]}
	\end{array}
	\]
	\[
	\begin{array}{c}
	\irule
	{\procX(\vec x,\vec y) \mmdef \procP \qquad 
		\sys {\pmv A} {\procP\subs{\vec u}{\vec x}\subs{\vec{e}}{\vec{y}} 
			\cocoPar \procQ} \mid \sysS 
		\pmove{\mu} \sysSi}
	{\sys {\pmv A} {\procX(\vec u,\vec e) \cocoPar \procQ} \mid \sysS \pmove{\mu} \sysSi}
	\; \nrule{[Def]}
	\hspace{30pt}
	\irule
	{\sysS \pmove{\mu} \sysSi}
	{\sysS \mid \sysSii \pmove{\mu} \sysSi \mid \sysSii}
	\; \nrule{[Par]}
	\\[15pt]
	\irule
	{\sysS \pmove{\lbl A {\pref}} \sysSi}
	{(u)\sysS \pmove{\lbl A {\del u {\pref}}} (u)\sysSi}
	\; \nrule{[Del]}
	\hspace{20pt}
	\text{where } \del u {\pref} =
	\begin{cases}
	\tau & \text{if } u \in \fnv{\pref}\\
	\pref & \text{otherwise}
	\end{cases}
	\end{array}
	\]
	\hrulefill
	\vspace{-5pt}
	\caption{Reduction semantics of \coco\!\!.} \label{fig:co2:semantics}
	% \vspace{-10pt}
\end{figure}

\medskip
We now briefly discuss the rules in~\Cref{fig:co2:semantics}.
Rule~\nrule{[Tau]} just fires a $\tau$ prefix.
%
Rule~\nrule{[Tell]} advertises a latent contract 
$\setenum{\freeze{x\!}{\contrP}}_{\pmv A}$.
%
Rule~\nrule{[Fuse]} finds \emph{agreements} among the latent contracts:
this happens when there exist
$\setenum{\freeze{x\!\!}{\contrP}}_{\pmv A}$ and 
$\setenum{\freeze{y\!\!}{\contrQ}}_{\pmv B}$
such that $\pmv A \!\neq\! \pmv B$ and $\contrP \!\compliant\! \contrQ$.
Once an agreement is found, 
a fresh session containing $\gamma = \bic{\contrP}{\contrQ}$ is created.
%
Rule~\nrule{[If]} evaluates the guard of a conditional,
and then proceeds with one of the branches.
%
Rule \nrule{[Do$\bang$]} allows a participant $\pmv A$ to 
choose a branch label in a contract configuration $\gamma$ within session $s$,
and to send the value resulting from the evaluation of $\expE$
(which results in $\gamma$ evolving to a suitable $\gammai$).
%
Rule \nrule{[Do$\qmark$]} allows $\pmv A$ to 
receive a value $\valV$, resulting from a $\nrule{[Rdy]}$ transition 
of the contract configuration $\gamma$ within session $s$,
and to bind to $\valV$ the free occurrences of $x$ 
within the continuation $\procP$.
%
Rule \nrule{[Ask]} allows $\pmv A$ to proceed only if 
the contract $\gamma$ at session $s$ satisfies the formula $\phi$.
%
The last three rules are mostly standard.
In rule [$\nrule{Del}$] the label $\pref$ fired in the premise
becomes $\tau$ in the consequence, 
when $\pref$ contains the delimited name/variable.
This transformation is defined by the function $\del{u}{\pref}$:
% where the set $\fnv{\pref}$ contains the free names/variables in $\pref$.
for instance, 
\(
(x) \, \sys {\pmv A} {\tell {} {\freeze{x} \contrP}. \procP} 
\pmove{\lbl A {\tau}} 
(x) \, (\sys {\pmv A} \procP \,\mid\, \setenum{\freeze{x\!}{\contrP}}_{\pmv A})
\). 
Here, it would make little sense to have 
the label $\lbl {A} {\tell {} {\freeze{x\!}{\contrP}}}$, 
as $x$ (being delimited) may be $\alpha$-converted.

\medskip
Hereafter, we shall assume that systems are always \emph{well-typed}, \ie:
\begin{inlinelist}
	
	\item the syntactic constraints required in~\Cref{sec:co2:syntax} are respected;
	
	\item the guards in conditionals have sort \sort{bool};
	
	\item the sorts of the expressions passed to named processes are coherent 
	with those in the corresponding defining equations.
	
\end{inlinelist}
Ensuring such form of well-typedness can be easily done through standard 
type checking techniques.




\subsection{Honesty} \label{sec:co2:honesty}
\coco allows for writing \emph{dishonest} agents which 
do not fulfil their contractual obligations, in some contexts.
To formalise the notion of honesty,
% by adapting the one appeared in~\cite{BMSZ14wrla}.
% 
we start by defining the set $\obbl {\pmv A} s \sysS$ of \emph{obligations} 
of a participant $\pmv A$ at a session $s$ in $\sysS$. 
The intuition is that, whenever $\pmv A$ is culpable at some session $s$, 
she has to fire one of the actions in $\obbl {\pmv A} s \sysS$
to exculpate herself 
(possibly in two steps, according to~\Cref{th:compliant-smiley}).

\begin{definition}[Obligations] 
	\label{def:obligations}
	\label{def:systemCulpable}
	We define the set of branch labels $\obbl {\pmv A} {s} {\sysS}$ as:
	\[
	\obbl {\pmv A} {s} {\sysS} 
	\; = \;
	\setcomp {\atom a} {\exists \gamma,\sysSi,\valV,\circ \; : \;
		\sysS 
		\equiv \sys s \gamma \mid \sysSi \text{ and } 
		\gamma \cmove{{\pmv A} \says {\atom a} \circ \valV}}
	\vspace{-2pt}
	\]
	% Let $S=\sys s {\gamma}\mid S'$. 
	We say that $\pmv A$ is \emph{culpable at $s$ in $\sysS$} 
	% iff $ \cfrown {\pmv A} {\gamma}$.
	iff $\obbl {\pmv A} {s} {\sysS} \neq \emptyset$.
\end{definition}

A participant $\pmv A$ is \emph{ready} in a system $\sysS$ %
if, whenever $\pmv A$ obligations in $\sysS$, she can fulfil some of them  %
(so, if $\pmv A$ does not occur in $\sysS$ or has no obligations there,
then she is trivially ready). %
% i.e.\ she can exculpate herself. 
To check if {\pmv A} is ready in $\sysS$, 
we consider all the sessions $s$ in $\sysS$ involving~{\pmv A}. %
For each of them, we check that some obligations of {\pmv A} at $s$
are exposed after some steps of {\pmv A}
\emph{not} preceded by other $\fact{s}{\!}$ of {\pmv A}.
% These actions form the set $\readydoweak{s}{\pmv A}{\sysS}$.
% This allows for avoiding problems with $\alpha$-conversion.   
The set $\RdyS{\pmv A}{s}$ collects all the systems 
where {\pmv A} may perform some action at $s$ after a finite sequence 
of transitions of {\pmv A} not involving any $\fact{}{}\!$ at $s$.
Note that {\pmv A} is vacuously ready in all systems in which she does
not have any obligations.
% (note that, by rule [\nrule{Del}], if $s$ is a bound name 
% then $\obbl{\pmv A} s {\sysS} = \emptyset$,
% hence {\pmv A} is ready at $s$ in $\sysS$).

\begin{definition}[Readiness] \label{def:ready_at}
	\vbox{
		We define the set of systems $\RdyS {\pmv A}{s}$ 
		as the smallest set such that:
		\begin{enumerate}
			
			\item \(
			\sysS \pmove{\lbl A {\fact s {}}} 
			\;\;\implies\; 
			\sysS \in \RdyS {\pmv A} {s}
			\)\label{def:ready_at:i}
			
			\item \(
			\big( \sysS \pmove{\lbl A{\neq \fact {s} {}}} \sysSi 
			\;\land\; 
			\sysSi \in \RdyS {\pmv A} {s} \big) 
			\implies 
			\sysS \in \RdyS {\pmv A} {s}
			\)\label{def:ready_at:ii}
			
		\end{enumerate}
	} % vbox
	%
	\noindent
	Then, we say that: 
	\begin{enumerate}
		
		\item \label{it:ready:ready-at}
		{\pmv A} is \emph{ready at $s$ in $\sysS$} 
		whenever $\sysS \in \RdyS {\pmv A} {s}$.
		
		\item \label{it:ready:ready} 
		{\pmv A} is \emph{ready in $\sysS$} iff
		\(
		\;
		\forall s,\sysSi,\vec u \; : \; %
		\sysS \equiv (\vec u) \,\sysSi
		\;\land\;
		\obbl {\pmv A} {s} {\sysSi} \neq \emptyset 
		\;\implies
		\sysSi \in \RdyS{\pmv A}{s}
		\)
	\end{enumerate}
\end{definition}


We can now formalise when a participant is \emph{honest}. %
Roughly,
$\sys{\pmv{A}}{\procP}$ is honest in a \emph{fixed} system $\sysS$
when $\pmv{A}$ is ready in all evolutions of 
$\sys{\pmv{A}}{\procP} \mid \sysS$. %
Then, we say that 
$\sys{\pmv{A}}{\procP}$ is honest when she is honest in \emph{all} %
systems~$\sysS$.

\begin{definition}[Honesty] % readiness, $\pmv{A}$-freedom] 
	\label{def:ready}
	\label{def:honesty}
	We say that:
	\begin{enumerate}
		
		\item \emph{$\sysS$ is $\pmv{A}$-free} iff it has no latent/stipulated
		contracts of $\pmv{A}$, nor processes of $\pmv{A}$
		
		\item \label{it:honesty:honest-in} $\procP$ is \emph{honest in $\sysS$} iff
		\begin{center}
		$\forall {\pmv A} : \left(
		\sysS \text{ is {\pmv A}-free} %
		\,\land\, \sys {\pmv A} \procP \mid \sysS \pmove{}^* \sysSi %
		\right)
		\implies {\pmv A} \text{ is ready in } \sysSi$
		\end{center}
		
		\item \label{it:honesty:honest} $\procP$ is \emph{honest} iff\;\ 
		$\forall \sysS : \procP \text{ is honest in } \sysS$.
		
	\end{enumerate}
\end{definition}

Note that in~\cref{it:honesty:honest-in} we are quantifying 
over all $\pmv A$: this is just needed to associate $\procP$
to a participant name, with the only constraint that 
such name must not be present in the environment $\sysS$ 
used to test $\procP$.
In the absence of the {\pmv A}-freeness constraint, 
the notion of honesty would be impractically strict: %
indeed, were $\sysS$ already carrying stipulated 
or latent contracts of $\pmv A$, \eg with
$\sysS = \sys s {\bic{\atomOut{pay100Keu}}{\atomIn{pay100Keu}}}$,
it would be unreasonable to ask participant $\pmv A$ to fulfil them. % 
%
Note however that $\sysS$ can contain latent contracts
and sessions involving \emph{any} other participant different from $\pmv A$:
in a sense, the honesty of $\sys {\pmv A} {\procP}$ ensures a good behaviour
even in the (quite realistic) case where
$\sys {\pmv A} {\procP}$ is inserted in a system which has already started. %

\begin{example}[Basic examples of honesty] \label{ex:honesty:basic}
	Consider the following processes:
	\begin{enumerate}
		
		\item \label{ex:co2-honesty:1} \quad
		\(
		% \hyperref[ex:co2-honesty:1]{\procP[\ref*{ex:co2-honesty:1}]}
		\procP[\ref*{ex:co2-honesty:1}]
		\; = \; (x) \;
		\tell {} {\freeze{x}{\atomOut{a} \sumInt \atomOut{b}}} \cocoSeq
		\fact x {\atomOut{a}}
		\)
		
		\item \label{ex:co2-honesty:2} \quad
		\(
		\procP[\ref*{ex:co2-honesty:2}]
		\; = \; (x) \; 
		\tell {} {\freeze{x}{\atomOut{a}}} \cocoSeq
		\left(
		\tau . \fact x {\atomOut{a}} \cocoPlus \tau . \fact x {\atomOut{b}}
		\right)
		\)
		
		\item \label{ex:co2-honesty:3} \quad
		\(
		\procP[\ref*{ex:co2-honesty:3}]
		\; = \; (x) \; 
		\tell {} {\freeze{x}{\atomIn{a} \sumExt \atomIn{b}}} \cocoSeq
		\fact x {\atomIn{a}}
		\)
		
		\item \label{ex:co2-honesty:ext-honest} \quad
		\(
		\procP[\ref*{ex:co2-honesty:ext-honest}]
		\; = \; (x) \; 
		\tell {} {\freeze{x}{\atomIn{a} \sumExt \atomIn{b}}} 
		\cocoSeq
		\big(
		\fact x {\atomIn{a}} \cocoPlus
		\fact x {\atomIn{b}} \cocoPlus
		\fact x {\atomIn{c}}
		\big)
		\)
		
		\item \label{ex:co2-honesty:5} \quad
		\(
		\procP[\ref*{ex:co2-honesty:5}]
		\; = \; (x, \, y) \;
		\tell {} {\freeze{x}{\atomIn{a}}} \cocoSeq 
		\tell {} {\freeze{y}{\atomOut{b}}} \cocoSeq 
		\fact x {\atomIn{a}} \cocoSeq
		\fact y {\atomOut{b}}
		\)
		
		\item \label{ex:co2-honesty:rec-tau} \quad
		\(
		\procP[\ref*{ex:co2-honesty:rec-tau}]
		\; = \; (x) \; 
		\tell {} {\freeze{x}{\atomOut{a}}} \cocoSeq \procX(x)
		\hspace{20pt}
		% \procX(x) \mmdef \ifte{\expE}{\fact x {\atomOut{a}}}{\tau \cocoSeq \procX(x)}
		\procX(x) \mmdef \tau \cocoSeq \tau \cocoSeq \procX(x) \cocoPlus \tau \cocoSeq \fact x {\atomOut{a}}
		\)
		
		\item \label{ex:co2-honesty:rec-if} \quad
		\(
		\procP[\ref*{ex:co2-honesty:rec-if}]
		\; = \; (x) \;
		\tell {} {\freeze{x}{\atomOut{a}}} \cocoSeq \procX(x)
		\hspace{10pt}
		\procX(x) \mmdef \ifte {\true} {\tau \cocoSeq \procX(x)}{\fact x {\atomOut{a}}}
		\) 
		
		% \item \label{ex:co2-honesty:7} \quad
		%   \(
		%   \procP[\ref*{ex:co2-honesty:7}]
		%   \; = \; (x) \;
		%   \tell {} {\freeze{x}{\atomOut{a}}} \cocoSeq \procX(x)
		%   \hspace{30pt}
		%   \procX(x) \mmdef {\tau \cocoSeq \tau \cocoSeq \procX(x)} \cocoPlus
		%   {\tau \cocoSeq\fact y {\atomOut{a}}}
		%   \) 
		
	\end{enumerate}
	We now discuss the honesty (or dishonesty) of these processes.
	\begin{itemize}
		
		\item $\procP[\ref*{ex:co2-honesty:1}]$ is honest:
		it is advertising an internal choice between $\atomOut{a}$ and $\atomOut{b}$,
		and then it is doing $\atomOut{a}$.
		
		\item $\procP[\ref*{ex:co2-honesty:2}]$ is dishonest:
		if the rightmost $\tau$ is fired, then the process cannot do the promised $\atomOut{a}$.
		Note that $\procP[\ref*{ex:co2-honesty:2}]$ is dishonest in \emph{all}
		contexts where the session $x$ is fused.
		
		\item $\procP[\ref*{ex:co2-honesty:3}]$ is dishonest:
		indeed, if the other participant involved at session $x$ chooses $\atomOut{b}$,
		then $\procP[\ref*{ex:co2-honesty:3}]$ cannot do the corresponding input.
		Note instead that $\procP[\ref*{ex:co2-honesty:3}]$ is honest in all 
		contexts where either the session $x$ is not fused,
		or the other participant at $x$ does not fire $\atomOut{b}$.
		
		\item $\procP[\ref*{ex:co2-honesty:ext-honest}]$ is honest:
		note that the branch $\atomIn{c}$ can never be taken.
		Indeed, an action can be fired by a process at session $s$
		only if it is enabled by the contract configuration in $s$
		(see the premise of rule~\nrule{[Do$\qmark$]}).
		
		\item $\procP[\ref*{ex:co2-honesty:5}]$ is dishonest,
		for two different reasons.
		First, in contexts where session $y$ is fused and $x$ is not, 
		the $\fact y {\atomOut{b}}$ cannot be reached 
		(and so the contract at session $y$ is not fulfilled).
		Second, also in those contexts where both sessions are fused,
		if the other participant at session $x$ never does $\atomOut{a}$,
		then $\fact y {\atomOut{b}}$ cannot be reached.
		
		\item $\procP[\ref*{ex:co2-honesty:rec-tau}]$ is honest. The process
		is advertising a singleton internal choice, and then
		non-deterministically choosing to either perform an internal action followed by
		the $\fact{}{}\!$ action, or to perform an internal action
		and then loop. %
		Although there exists a computation where $\atomOut{a}$ is never
		performed (the infinite sequence of internal actions), under a fair scheduler
		the rightmost $\tau$s, which is enabled infinitely often, 
		will be performed. %
		We now show that $\procP[\ref*{ex:co2-honesty:rec-tau}]$ 
		is honest in  
		$\sysS = (y) (\setenum{\freeze y {\atomIn{a}}}_{\pmv B})$, with $\pmv A \neq \pmv B$
		(the generalisation to arbitrary contexts is straightforward). %
		The reachable states from $\sys{\pmv A}{\procP[\ref*{ex:co2-honesty:rec-tau}]} \mid \sysS$
		(up-to structural congruence) are the following:
		\begin{enumerate}
			
			\item $\sys{\pmv A}{\procP[\ref*{ex:co2-honesty:rec-tau}]} \mid \sysS$. %
			Here $\pmv A$ is vacuously ready, 
			because no session has been established yet. %
			
			\item $(x,y)(\sys{\pmv A}{\procX(x)} \mid 
			\setenum{\freeze x {\atomOut{a}}}_{\pmv A} \mid 
			\setenum{\freeze y {\atomIn{a}}}_{\pmv B})$. %
			Here $\pmv A$ is vacuously ready, as in the previous item. %
			
			\item $(s)(\sys{\pmv A}{\fact s {\atomOut{a}}} \mid 
			\sys s {\bic {\atomOut{a}} {\atomIn{a}}})$.
			Here $\pmv A$ is ready, because
			$\sys{\pmv A}{\fact s {\atomOut{a}}} \mid \sys s {\bic {\atomOut{a}} {\atomIn{a}}}
			\in \RdyS {\pmv A} {s}$, 
			by~\cref{def:ready_at:i} of~\Cref{def:ready_at}. %
			
			\item $(s)(\sys{\pmv A}{\procX(s)} \mid 
			\sys s {\bic {\atomOut{a}} {\atomIn{a}}})$.
			%
			Since $\sys{\pmv A}{\procX(s)} \mid \sys s {\bic {\atomOut{a}} {\atomIn{a}}} 
			\pmove{\lbl A {\tau}} \sys{\pmv A}{\fact s {\atomOut{a}}} \mid 
			\sys s {\bic {\atomOut{a}} {\atomIn{a}}}$,
			which is ready for the previous item,
			then $\pmv A$ is ready. 
			
			\item $(s)(\sys{\pmv A}{\pnil} \mid 
			\sys s {\bic {\cnil} {\ready{\atomIn a}}})$.
			Here $\pmv A$ is vacuously ready,      
			because she has not obligations in $s$. 
			% (participant $\pmv B$ has to do the input $\atomIn{a}$). %
			
		\end{enumerate}
		
		\item $\procP[\ref*{ex:co2-honesty:rec-if}]$ is dishonest:
		it is advertising a singleton internal choice, and then, since the condition
		in the $\cond$ is $\true$, it can never take the branch which would fulfil the
		obligation to do $\atomOut{a}$.
		
	\end{itemize}
\end{example}

Observe that~\cref{ex:co2-honesty:rec-if,ex:co2-honesty:rec-tau} in~\Cref{ex:honesty:basic}
show that it would be \emph{incorrect} to verify the honesty of a process
$\ifte{\expE}{\procP}{\procQ}$ as we would do for 
process $\tau \cocoSeq \procP \cocoPlus \tau \cocoSeq \procQ$. %


\section{Model checking honesty}\label{sec:co2-model-check}

We now address the problem of automatically verifying honesty.
However, this is a desirable goal, 
because it alerts system designers before they
deploy services which could violate contracts at run-time 
(so possibly incurring in sanctions).
%
Since honesty is undecidable in general~\cite{BTZ12coordination}
(also when restricting to \coco without value-passing), 
our goal is a verification technique which safely over-approximates it:
\ie, only honest processes must be classified as such.

A first issue is that~\Cref{def:honesty}
requires readiness to be preserved in \emph{all} possible contexts,
and there is an \emph{infinite} number of such contexts.
Another issue is that, even considering a fixed context 
and the usual syntactic restrictions required to make
processes finite-state
(\eg\ no delimitation/parallel under process definitions),
value-passing makes the semantics of \coco infinite-state.

To overcome these problems, recently \cite{verifiable} proposed a new approach to check if a \coco process is honest. The idea is to provide an abstract semantics of \coco, obtained in two steps.

\begin{enumerate}
	
	\item First, they devise a \emph{value abstraction} $\vabs{}$ 
	of systems, which replaces each expression $\expE$
	with a special value $\vabsDummy$.
	They show that value abstraction is \emph{sound}
	with respect to honesty: \ie, if $\vabs{\procP}$ is honest,
	then also the concrete process $\procP$ is honest.
	Furthermore, value abstraction is \emph{complete} whenever $\procP$
	contains no conditional expressions, \ie\ if $\procP$ is honest
	and it is $\cond$-free, then $\vabs{\procP}$ is honest, too.
	
	\item Second, they provide a \emph{context abstraction} $\cabs[A]{}$ 
	of contracts and systems.
	The abstraction $\cabs[A]{}$ is parameterised by the 
	participant {\pmv A} the honesty of which is under consideration:
	basically, $\cabs[A]{\sysS}$ discards the part of the system $\sysS$
	not governed by {\pmv A}, by over-approximating its moves.
	%
	They states that this abstraction is sound, too,
	and it is also complete for $\ask{}{}$-free processes.
\end{enumerate}

Summing up, by composing the two abstractions they obtain
a sound over-approximation of honesty:
namely, if $\cabs[A]{\vabs{\procP}}$ is honest,
then the concrete process $\procP$ is honest.
Conversely, if $\procP$ is honest, $\cond$-free and $\ask{}{}$-free,
then $\cabs[A]{\vabs{\procP}}$ is honest, too.
When $\procP$ is a finite state process
(\ie, without delimitation/parallel under process definitions),
then the honesty of $\cabs[A]{\vabs{\procP}}$ 
can be verified by model checking its state space.

\subsection{Maude model checker}\label{sec:maude:checker}

A checker for honesty is implemented in Maude \cite{Maude01} and described in details in \cite{verifiable}. This tool is widely used into the implementation provided with this master thesis, both in the Eclipse plug-in and in the Java model checker, described respectively in \Cref{chap:co2-to-java} and \Cref{chap:java-honesty}. The checker can be downloaded at ?? %\citeurl{co2-maude-download-link}% (visited on 2015-08).

\subsubsection{Voucher distribution system}\label{ex:voucher}
We present an example modelled in maude so the reader can realize the difficulty on write processes in this way. In \Cref{chap:use-cases} we present some examples that highlight how this task is simplified using the \coco Eclipse plug-in.

% \bartnote{the comments and code must be completely rewritten, but the example should be ok}
\newcommand{\cp}{\atom{clickPay}}
\newcommand{\cv}{\atom{clickVoucher}}
\newcommand{\p}{\atom{pay}}
\newcommand{\vou}{\atom{voucher}}
\newcommand{\rj}{\atom{reject}}
\newcommand{\ac}{\atom{accept}}
\newcommand{\ctc}{\atom{clickPay}.\p \sumExt \cv.(\rj.\p \sumInt \ac.\vou)}
\newcommand{\ctv}{\atom{ok} \sumExt \atom{no}}
%
A store {\pmv A} offers buyers two payment options: \cp\ or \cv.
%
If a buyer {\pmv B} chooses \cp, {\pmv A} requires {\pmv B} to \p;
otherwise, {\pmv A} checks the validity of the voucher with {\pmv V}, an
online voucher distribution system.
%
If {\pmv V} validates the voucher (\atom{ok}), {\pmv B} can use it (\vou),
otherwise (\atom{no}) {\pmv B} must \p.

We specify the contracts $\contrP[\pmv B]$ (between {\pmv A} and {\pmv B}) 
and $\contrP[\pmv V]$ (between {\pmv A} and {\pmv V}) 
as follows:
\begin{align*}
\contrP[\pmv B] = \,
&
\atomIn{clickPay} \, . \,
\atomIn{pay}\sort{string} 
\; \sumExt \;
\atomIn{clickVoucher} 
\, . \, \\ &
\left(
\atomOut{reject} 
\, . \,
\atomIn{pay}\sort{string} 
\; \sumInt \;
\atomOut{accept} 
\, . \,
\atomIn{voucher}\sort{string}
\right)
\\
\contrP[\pmv V] = \, &
\atomIn{ok} \;\sumExt\; \atomIn{no}
\end{align*}
% $c_{\pmv A} = \ctc$ and $c'_{\pmv A} = \ctv$ model the
%  scenario above.
%
In~\cite{BTZ12coordination} a \coco\ process for \pmv{A} 
was specified as follows:
\begin{align*}
\procP \; = \; & 
(x) \
\big(\,
\tell{}{\freeze x {\contrP[\pmv B]}} \,
\cocoSeq \, \\ &
\left(
\fact x {\atomIn{\cp}} \cocoSeq \fact x {\atomIn{\p}}
\, \cocoPlus \,
\fact x {\atomIn{\cv}} \cocoSeq (y) \ \tell{} {\freeze y {\contrP[\pmv V]}} \cocoSeq \procQ
\right)%
\big)
\\
\procQ\; = \; &
\fact y {\atomIn{ok}} 
\cocoSeq
\fact x {\atomOut{\ac}} 
\cocoSeq 
\fact x {\atomIn{\vou}}
\; \\ &\cocoPlus \;  
\fact y {\atomIn{no}}
\cocoSeq
\fact x {\atomOut{\rj}} 
\cocoSeq 
\fact x {\atomIn{\p}}
\; \\&\cocoPlus \;  
\tau \cocoSeq \procR
\\
\procR \; = \; &
\fact x {\atomOut{\rj}} 
\cocoSeq 
\fact x {\atomIn{\p}}
\end{align*}

\noindent
Variables $x$ and $y$ in $\procP$ correspond to two separate
sessions, where {\pmv A} interacts with {\pmv B} and {\pmv V}, respectively.
The advertisement of $\contrP[\pmv V]$ causally depends on the
stipulation of the contract $\contrP[\pmv B]$, 
because {\pmv A} must fire \cv\ before the rightmost $\tell{}{}$.
%
In process $\procQ$ the store waits for an answer from {\pmv V}:
if {\pmv V} validates the voucher (first branch), 
then {\pmv A} accepts it from {\pmv B};
if {\pmv V} rejects the voucher (second branch), 
then {\pmv A} requires {\pmv B} to pay.
The third branch $\tau \cocoSeq \procR$ allows {\pmv A} to fire a $\tau$ action,
and then reject the voucher.
Here $\tau$ models a timeout, 
to deal with the fact that $\contrP[\pmv V]$ might either 
not be stipulated, or {\pmv V} might take too long to answer.

The above process is modelled in Maude as follows:
\begin{lstlisting}[language=maude]
in co2-abs .

mod VOUCHER is
*** for verifiying honesty
including CO2-ABS-SEM .

ops clickPay clickVoucher pay voucher accept 
    reject ok no : -> ActName [ctor] .

ops x y : -> SessionVariable [ctor] .
ops CB Cvoucher CV : -> UniContract .
ops string bool int unit : -> BType [ctor] .

eq CB = clickPay ? unit . pay ? string . 0 + clickVoucher ? unit . Cvoucher .
eq Cvoucher = reject ! unit . pay ? string . 0 (+) accept ! unit . voucher ? string . 0 .

eq CV = ok ? unit . 0 + no ? unit . 0 .

ops P Q R : -> Process .  

eq P = (x)(tell x CB . (
do x clickPay ? unit . do x pay ? string . 0 
+ do x clickVoucher ? unit . ((y) tell y CV . Q))) .

eq Q = do y ok ? unit . do x accept ! unit . do x voucher ? string . 0 
    + do y no ? unit . do x reject ! unit . do x pay ? string . 0     
    + R .

eq R = t . (do x reject ! unit . do x pay ? string . 0) .

endm

*** should be dishonest
red honest(P , ['VOUCHER], unbounded) .
\end{lstlisting}

The model checker has determined the dishonesty of that process, 
and by exploiting the Maude tracing facilities we managed to fix it.
Actually, when we check the honesty of $\procP$, 
Maude gives the following output:
\begin{lstlisting}
red honest(P , ['VOUCHER], unbounded) .
rewrites: 36668 in 76ms cpu (76ms real) (482473 rewrites/second)
result TSystem: < ($ 0,$ 1)(A[do $ 0 reject ! unit . do $ 0 pay ? string . (0).Sum] |
$ 0[accept ! unit . voucher ? string . 0(+)reject ! unit . pay ? string . 0] | 
$ 1[ready ok ? unit . 0]) >
\end{lstlisting}
The last three lines of the output above show a state where {\pmv A} is not ready:
there, {\pmv A} must do $\atom{ok}$ in session \mbox{\code{\$1}}
(which corresponds to variable $y$ in the \coco specification),
while {\pmv A} is only ready to do a \rj\ at session \code{\$0} 
(which corresponds to $x$).
This problem occurs when branch $\tau \cocoSeq \procR$ is chosen
(actually, the code within \code{A[...]} is that of $\procR$).
Since $\procP$ is $\ask{}{}$-free and $\cond$-free, by completeness
of abstract honesty it follows that $\procP$ is dishonest.
%
To recover honesty, it suffices to replace $\procR$ with the following process $\procRi$, %
where $\pmv{A}$ is ready to handle $\pmv{V}$'s answer when $y$ is instantiated:
\[
\procRi
\; = \;
\left(
% \tau
% \cocoSeq
\fact x {\atomOut{\rj}} 
\cocoSeq
\fact x {\atomIn{\p}}
\right)
\; \cocoPar \;
\left(
\fact y {\atomIn{no}}
\cocoPlus
\fact y {\atomIn{ok}}
\right)
\]
Let $\procPi$ be the store process with the modifications above.
Using the Maude model checker, now we obtain:
% eq R' = t . (do x reject ! unit . do x pay ? string . 0 | (do y no ? unit . 0 + do y ok ? unit . 0)) .
\begin{lstlisting}
red honest(P' , ['VOUCHER], 3) .
rewrites: 51201 in 44ms cpu (42ms real) (1163659 rewrites/second)
result Bool: true
\end{lstlisting}
So we deduce that the $\procPi$ is honest.


\section{Contract oriented middleware}\label{sec:co2-middleware}
The following section briefly describe a \textit{contract-oriented middleware} \cite{CO2middleware} that aims to monitor the interaction between mutually distrusting services and simplify the development of distributed applications.
A service can \textit{advertise} its contract without worrying about the search of a \textit{compliant} peer to interact with. The middleware carry about the creation of a session and monitors the involved services to detect contract violations.

In order to interact with the middleware, a developer can choose between the RESTFUL API, whose drawback is warring of the order of API calls, and language specific API, that partially guide it to the correct usage. At the time of writing, there is a Java API we used in our implementation (see \Cref{chap:co2-to-java} and \Cref{chap:java-honesty}).

\subsection{Java API}\label{sec:co2-middleware-api}

%\begin{listing}[t]
%	\inputJavaLineos{code/HelloWorld.txt}
%	\caption{Hello world.}
%	\label{lst:hello-world}
%\end{listing}

This section shows the Java API usage \textit{by example}. 

\Cref{lst:hello-world} shows a simple ``hello world'' example. %
At lines~\lineno{1-2} the process establishes 
a connection with the middleware. %
% In our first example we focus on the basic client APIs that allow to: build a new contract,
% wait for a compliant one, handle a session.
The contract (constructed at line~\lineno{4}) advertise that the process wants to send a $\atom{greet}$ing message, and waits to receive the name of the greeted planet.

At line~\lineno{6}, we construct a \incodeType{Private} object, in a state where it has not been advertised to the middleware, yet. %
As soon as it is advertised  by invoking the \incodeMethod{tell} 
method  at line~\lineno{7}, its state is changed into \incodeType{Public}.
At line~\lineno{9}, it waits for a session to be established; 
so that a \incodeType{Session} object is created, 
through which the process can interact with the participant at the other endpoint. 
At line~\lineno{10}, it says \incode{hello}, 
by sending a message with label $\atom{greet}$. % 
%
At line~\lineno{13}, it waits to receive a \incodeType{Message}. %
If the other participant respects its contract,
\incodeMethod{getStringValue} at line~\lineno{14} 
gets the string associated to the $\atom{planet}$ action,
and the session terminates successfully. %
Otherwise, the \incodeMethod{waitForReceive} is unblocked,
and a \incodeType{ContractException} is caught at line~\lineno{12}.

You can download the Java API, the related documentation and some examples at ????%\citeurl{CO2middleware} (visited on 2015-08).

\subsubsection{Contract advertisement}
The API allows us to advertise a contract only as plain Java \incodeType{String} in two formats: XML and \textit{timed session-types} \cite{Bartoletti15forte}. The former is too verbose and does not strictly comply our session-types definition (see \Cref{def:contracts:syntax}); the latter is a superset of our specification, so we prefer to use it on communicating with the middleware.

In \Cref{chap:co2-to-java} we show an extended version of these API, providing a Java representation for contracts.

